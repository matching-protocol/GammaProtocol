{
  "language": "Solidity",
  "sources": {
    "contracts/core/AddressBook.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity =0.6.10;\n\nimport {Ownable} from \"../packages/oz/Ownable.sol\";\nimport {OwnedUpgradeabilityProxy} from \"../packages/oz/upgradeability/OwnedUpgradeabilityProxy.sol\";\n\n/**\n * @author Opyn Team\n * @title AddressBook Module\n */\ncontract AddressBook is Ownable {\n    /// @dev Otoken implementation key\n    bytes32 private constant OTOKEN_IMPL = keccak256(\"OTOKEN_IMPL\");\n    /// @dev OtokenFactory key\n    bytes32 private constant OTOKEN_FACTORY = keccak256(\"OTOKEN_FACTORY\");\n    /// @dev Whitelist key\n    bytes32 private constant WHITELIST = keccak256(\"WHITELIST\");\n    /// @dev Controller key\n    bytes32 private constant CONTROLLER = keccak256(\"CONTROLLER\");\n    /// @dev MarginPool key\n    bytes32 private constant MARGIN_POOL = keccak256(\"MARGIN_POOL\");\n    /// @dev MarginCalculator key\n    bytes32 private constant MARGIN_CALCULATOR = keccak256(\"MARGIN_CALCULATOR\");\n    /// @dev LiquidationManager key\n    bytes32 private constant LIQUIDATION_MANAGER = keccak256(\"LIQUIDATION_MANAGER\");\n    /// @dev Oracle key\n    bytes32 private constant ORACLE = keccak256(\"ORACLE\");\n\n    /// @dev mapping between key and address\n    mapping(bytes32 => address) private addresses;\n\n    /// @notice emits an event when a new proxy is created\n    event ProxyCreated(bytes32 indexed id, address indexed proxy);\n    /// @notice emits an event when a new address is added\n    event AddressAdded(bytes32 indexed id, address indexed add);\n\n    /**\n     * @notice return Otoken implementation address\n     * @return Otoken implementation address\n     */\n    function getOtokenImpl() external view returns (address) {\n        return getAddress(OTOKEN_IMPL);\n    }\n\n    /**\n     * @notice return oTokenFactory address\n     * @return OtokenFactory address\n     */\n    function getOtokenFactory() external view returns (address) {\n        return getAddress(OTOKEN_FACTORY);\n    }\n\n    /**\n     * @notice return Whitelist address\n     * @return Whitelist address\n     */\n    function getWhitelist() external view returns (address) {\n        return getAddress(WHITELIST);\n    }\n\n    /**\n     * @notice return Controller address\n     * @return Controller address\n     */\n    function getController() external view returns (address) {\n        return getAddress(CONTROLLER);\n    }\n\n    /**\n     * @notice return MarginPool address\n     * @return MarginPool address\n     */\n    function getMarginPool() external view returns (address) {\n        return getAddress(MARGIN_POOL);\n    }\n\n    /**\n     * @notice return MarginCalculator address\n     * @return MarginCalculator address\n     */\n    function getMarginCalculator() external view returns (address) {\n        return getAddress(MARGIN_CALCULATOR);\n    }\n\n    /**\n     * @notice return LiquidationManager address\n     * @return LiquidationManager address\n     */\n    function getLiquidationManager() external view returns (address) {\n        return getAddress(LIQUIDATION_MANAGER);\n    }\n\n    /**\n     * @notice return Oracle address\n     * @return Oracle address\n     */\n    function getOracle() external view returns (address) {\n        return getAddress(ORACLE);\n    }\n\n    /**\n     * @notice set Otoken implementation address\n     * @dev can only be called by the addressbook owner\n     * @param _otokenImpl Otoken implementation address\n     */\n    function setOtokenImpl(address _otokenImpl) external onlyOwner {\n        setAddress(OTOKEN_IMPL, _otokenImpl);\n    }\n\n    /**\n     * @notice set OtokenFactory address\n     * @dev can only be called by the addressbook owner\n     * @param _otokenFactory OtokenFactory address\n     */\n    function setOtokenFactory(address _otokenFactory) external onlyOwner {\n        setAddress(OTOKEN_FACTORY, _otokenFactory);\n    }\n\n    /**\n     * @notice set Whitelist address\n     * @dev can only be called by the addressbook owner\n     * @param _whitelist Whitelist address\n     */\n    function setWhitelist(address _whitelist) external onlyOwner {\n        setAddress(WHITELIST, _whitelist);\n    }\n\n    /**\n     * @notice set Controller address\n     * @dev can only be called by the addressbook owner\n     * @param _controller Controller address\n     */\n    function setController(address _controller) external onlyOwner {\n        updateImpl(CONTROLLER, _controller);\n    }\n\n    /**\n     * @notice set MarginPool address\n     * @dev can only be called by the addressbook owner\n     * @param _marginPool MarginPool address\n     */\n    function setMarginPool(address _marginPool) external onlyOwner {\n        setAddress(MARGIN_POOL, _marginPool);\n    }\n\n    /**\n     * @notice set MarginCalculator address\n     * @dev can only be called by the addressbook owner\n     * @param _marginCalculator MarginCalculator address\n     */\n    function setMarginCalculator(address _marginCalculator) external onlyOwner {\n        setAddress(MARGIN_CALCULATOR, _marginCalculator);\n    }\n\n    /**\n     * @notice set LiquidationManager address\n     * @dev can only be called by the addressbook owner\n     * @param _liquidationManager LiquidationManager address\n     */\n    function setLiquidationManager(address _liquidationManager) external onlyOwner {\n        setAddress(LIQUIDATION_MANAGER, _liquidationManager);\n    }\n\n    /**\n     * @notice set Oracle address\n     * @dev can only be called by the addressbook owner\n     * @param _oracle Oracle address\n     */\n    function setOracle(address _oracle) external onlyOwner {\n        setAddress(ORACLE, _oracle);\n    }\n\n    /**\n     * @notice return an address for specific key\n     * @param _key key address\n     * @return address\n     */\n    function getAddress(bytes32 _key) public view returns (address) {\n        return addresses[_key];\n    }\n\n    /**\n     * @notice set a specific address for a specific key\n     * @dev can only be called by the addressbook owner\n     * @param _key key\n     * @param _address address\n     */\n    function setAddress(bytes32 _key, address _address) public onlyOwner {\n        addresses[_key] = _address;\n\n        emit AddressAdded(_key, _address);\n    }\n\n    /**\n     * @dev function to update the implementation of a specific component of the protocol\n     * @param _id id of the contract to be updated\n     * @param _newAddress address of the new implementation\n     **/\n    function updateImpl(bytes32 _id, address _newAddress) public onlyOwner {\n        address payable proxyAddress = address(uint160(getAddress(_id)));\n\n        if (proxyAddress == address(0)) {\n            bytes memory params = abi.encodeWithSignature(\"initialize(address,address)\", address(this), owner());\n            OwnedUpgradeabilityProxy proxy = new OwnedUpgradeabilityProxy();\n            setAddress(_id, address(proxy));\n            emit ProxyCreated(_id, address(proxy));\n            proxy.upgradeToAndCall(_newAddress, params);\n        } else {\n            OwnedUpgradeabilityProxy proxy = OwnedUpgradeabilityProxy(proxyAddress);\n            proxy.upgradeTo(_newAddress);\n        }\n    }\n}\n"
    },
    "contracts/packages/oz/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts v3.1.0\n\npragma solidity 0.6.10;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/packages/oz/upgradeability/OwnedUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// openzeppelin-contracts-upgradeable v3.0.0\n\npragma solidity 0.6.10;\n\nimport \"./UpgradeabilityProxy.sol\";\n\n/**\n * @title OwnedUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n */\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\n    /**\n     * @dev Event to show ownership has been transferred\n     * @param previousOwner representing the address of the previous owner\n     * @param newOwner representing the address of the new owner\n     */\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\n\n    /// @dev Storage position of the owner of the contract\n    bytes32 private constant proxyOwnerPosition = keccak256(\"org.zeppelinos.proxy.owner\");\n\n    /**\n     * @dev the constructor sets the original owner of the contract to the sender account.\n     */\n    constructor() public {\n        setUpgradeabilityOwner(msg.sender);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyProxyOwner() {\n        require(msg.sender == proxyOwner());\n        _;\n    }\n\n    /**\n     * @dev Tells the address of the owner\n     * @return owner the address of the owner\n     */\n    function proxyOwner() public view returns (address owner) {\n        bytes32 position = proxyOwnerPosition;\n        assembly {\n            owner := sload(position)\n        }\n    }\n\n    /**\n     * @dev Sets the address of the owner\n     * @param _newProxyOwner address of new proxy owner\n     */\n    function setUpgradeabilityOwner(address _newProxyOwner) internal {\n        bytes32 position = proxyOwnerPosition;\n        assembly {\n            sstore(position, _newProxyOwner)\n        }\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\n        require(_newOwner != address(0));\n        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\n        setUpgradeabilityOwner(_newOwner);\n    }\n\n    /**\n     * @dev Allows the proxy owner to upgrade the current version of the proxy.\n     * @param _implementation representing the address of the new implementation to be set.\n     */\n    function upgradeTo(address _implementation) public onlyProxyOwner {\n        _upgradeTo(_implementation);\n    }\n\n    /**\n     * @dev Allows the proxy owner to upgrade the current version of the proxy and call the new implementation\n     * to initialize whatever is needed through a low level call.\n     * @param _implementation representing the address of the new implementation to be set.\n     * @param _data represents the msg.data to bet sent in the low level call. This parameter may include the function\n     * signature of the implementation to be called with the needed payload\n     */\n    function upgradeToAndCall(address _implementation, bytes calldata _data) public payable onlyProxyOwner {\n        upgradeTo(_implementation);\n        (bool success, ) = address(this).call{value: msg.value}(_data);\n        require(success);\n    }\n}\n"
    },
    "contracts/packages/oz/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts v3.1.0\n\npragma solidity 0.6.10;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/packages/oz/upgradeability/UpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// openzeppelin-contracts-upgradeable v3.0.0\n\npragma solidity 0.6.10;\n\nimport \"./Proxy.sol\";\n\n/**\n * @title UpgradeabilityProxy\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\n */\ncontract UpgradeabilityProxy is Proxy {\n    /**\n     * @dev This event will be emitted every time the implementation gets upgraded\n     * @param implementation representing the address of the upgraded implementation\n     */\n    event Upgraded(address indexed implementation);\n\n    /// @dev Storage position of the address of the current implementation\n    bytes32 private constant implementationPosition = keccak256(\"org.zeppelinos.proxy.implementation\");\n\n    /**\n     * @dev Tells the address of the current implementation\n     * @return impl address of the current implementation\n     */\n    function implementation() public view override returns (address impl) {\n        bytes32 position = implementationPosition;\n        assembly {\n            impl := sload(position)\n        }\n    }\n\n    /**\n     * @dev Sets the address of the current implementation\n     * @param _newImplementation address representing the new implementation to be set\n     */\n    function setImplementation(address _newImplementation) internal {\n        bytes32 position = implementationPosition;\n        assembly {\n            sstore(position, _newImplementation)\n        }\n    }\n\n    /**\n     * @dev Upgrades the implementation address\n     * @param _newImplementation representing the address of the new implementation to be set\n     */\n    function _upgradeTo(address _newImplementation) internal {\n        address currentImplementation = implementation();\n        require(currentImplementation != _newImplementation);\n        setImplementation(_newImplementation);\n        emit Upgraded(_newImplementation);\n    }\n}\n"
    },
    "contracts/packages/oz/upgradeability/Proxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// openzeppelin-contracts-upgradeable v3.0.0\n\npragma solidity 0.6.10;\n\n/**\n * @title Proxy\n * @dev Gives the possibility to delegate any call to a foreign implementation.\n */\nabstract contract Proxy {\n    /**\n     * @dev Tells the address of the implementation where every call will be delegated.\n     * @return address of the implementation to which it will be delegated\n     */\n    function implementation() public view virtual returns (address);\n\n    /**\n     * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n     * This function will return whatever the implementation call returns\n     */\n    fallback() external payable {\n        address _impl = implementation();\n        require(_impl != address(0));\n\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 {\n                revert(ptr, size)\n            }\n            default {\n                return(ptr, size)\n            }\n        }\n    }\n}\n"
    },
    "contracts/core/Whitelist.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.6.10;\n\nimport \"../interfaces/AddressBookInterface.sol\";\nimport \"../packages/oz/Ownable.sol\";\n\n/**\n * @author Opyn Team\n * @title Whitelist Module\n * @notice The whitelist module keeps track of all valid oToken addresses, product hashes, collateral addresses, and callee addresses.\n */\ncontract Whitelist is Ownable {\n    /// @notice AddressBook module address\n    address public addressBook;\n    /// @dev mapping to track whitelisted products\n    mapping(bytes32 => bool) internal whitelistedProduct;\n    /// @dev mapping to track whitelisted collateral\n    mapping(address => bool) internal whitelistedCollateral;\n    /// @dev mapping to track whitelisted oTokens\n    mapping(address => bool) internal whitelistedOtoken;\n    /// @dev mapping to track whitelisted callee addresses for the call action\n    mapping(address => bool) internal whitelistedCallee;\n\n    /**\n     * @dev constructor\n     * @param _addressBook AddressBook module address\n     */\n    constructor(address _addressBook) public {\n        require(_addressBook != address(0), \"Invalid address book\");\n\n        addressBook = _addressBook;\n    }\n\n    /// @notice emits an event a product is whitelisted by the owner address\n    event ProductWhitelisted(\n        bytes32 productHash,\n        address indexed underlying,\n        address indexed strike,\n        address indexed collateral,\n        bool isPut\n    );\n    /// @notice emits an event a product is blacklisted by the owner address\n    event ProductBlacklisted(\n        bytes32 productHash,\n        address indexed underlying,\n        address indexed strike,\n        address indexed collateral,\n        bool isPut\n    );\n    /// @notice emits an event when a collateral address is whitelisted by the owner address\n    event CollateralWhitelisted(address indexed collateral);\n    /// @notice emits an event when a collateral address is blacklist by the owner address\n    event CollateralBlacklisted(address indexed collateral);\n    /// @notice emits an event when an oToken is whitelisted by the OtokenFactory module\n    event OtokenWhitelisted(address indexed otoken);\n    /// @notice emits an event when an oToken is blacklisted by the OtokenFactory module\n    event OtokenBlacklisted(address indexed otoken);\n    /// @notice emits an event when a callee address is whitelisted by the owner address\n    event CalleeWhitelisted(address indexed _callee);\n    /// @notice emits an event when a callee address is blacklisted by the owner address\n    event CalleeBlacklisted(address indexed _callee);\n\n    /**\n     * @notice check if the sender is the oTokenFactory module\n     */\n    modifier onlyFactory() {\n        require(\n            msg.sender == AddressBookInterface(addressBook).getOtokenFactory(),\n            \"Whitelist: Sender is not OtokenFactory\"\n        );\n\n        _;\n    }\n\n    /**\n     * @notice check if a product is whitelisted\n     * @dev product is the hash of underlying asset, strike asset, collateral asset, and isPut\n     * @param _underlying asset that the option references\n     * @param _strike asset that the strike price is denominated in\n     * @param _collateral asset that is held as collateral against short/written options\n     * @param _isPut True if a put option, False if a call option\n     * @return boolean, True if product is whitelisted\n     */\n    function isWhitelistedProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external view returns (bool) {\n        bytes32 productHash = keccak256(abi.encode(_underlying, _strike, _collateral, _isPut));\n\n        return whitelistedProduct[productHash];\n    }\n\n    /**\n     * @notice check if a collateral asset is whitelisted\n     * @param _collateral asset that is held as collateral against short/written options\n     * @return boolean, True if the collateral is whitelisted\n     */\n    function isWhitelistedCollateral(address _collateral) external view returns (bool) {\n        return whitelistedCollateral[_collateral];\n    }\n\n    /**\n     * @notice check if an oToken is whitelisted\n     * @param _otoken oToken address\n     * @return boolean, True if the oToken is whitelisted\n     */\n    function isWhitelistedOtoken(address _otoken) external view returns (bool) {\n        return whitelistedOtoken[_otoken];\n    }\n\n    /**\n     * @notice check if a callee address is whitelisted for the call action\n     * @param _callee callee destination address\n     * @return boolean, True if the address is whitelisted\n     */\n    function isWhitelistedCallee(address _callee) external view returns (bool) {\n        return whitelistedCallee[_callee];\n    }\n\n    /**\n     * @notice allows the owner to whitelist a product\n     * @dev product is the hash of underlying asset, strike asset, collateral asset, and isPut\n     * can only be called from the owner address\n     * @param _underlying asset that the option references\n     * @param _strike asset that the strike price is denominated in\n     * @param _collateral asset that is held as collateral against short/written options\n     * @param _isPut True if a put option, False if a call option\n     */\n    function whitelistProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external onlyOwner {\n        require(whitelistedCollateral[_collateral], \"Whitelist: Collateral is not whitelisted\");\n        require(\n            (_isPut && (_strike == _collateral)) || (!_isPut && (_collateral == _underlying)),\n            \"Whitelist: Only allow fully collateralized products\"\n        );\n\n        bytes32 productHash = keccak256(abi.encode(_underlying, _strike, _collateral, _isPut));\n\n        whitelistedProduct[productHash] = true;\n\n        emit ProductWhitelisted(productHash, _underlying, _strike, _collateral, _isPut);\n    }\n\n    /**\n     * @notice allow the owner to blacklist a product\n     * @dev product is the hash of underlying asset, strike asset, collateral asset, and isPut\n     * can only be called from the owner address\n     * @param _underlying asset that the option references\n     * @param _strike asset that the strike price is denominated in\n     * @param _collateral asset that is held as collateral against short/written options\n     * @param _isPut True if a put option, False if a call option\n     */\n    function blacklistProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external onlyOwner {\n        bytes32 productHash = keccak256(abi.encode(_underlying, _strike, _collateral, _isPut));\n\n        whitelistedProduct[productHash] = false;\n\n        emit ProductBlacklisted(productHash, _underlying, _strike, _collateral, _isPut);\n    }\n\n    /**\n     * @notice allows the owner to whitelist a collateral address\n     * @dev can only be called from the owner address. This function is used to whitelist any asset other than Otoken as collateral. WhitelistOtoken() is used to whitelist Otoken contracts.\n     * @param _collateral collateral asset address\n     */\n    function whitelistCollateral(address _collateral) external onlyOwner {\n        whitelistedCollateral[_collateral] = true;\n\n        emit CollateralWhitelisted(_collateral);\n    }\n\n    /**\n     * @notice allows the owner to blacklist a collateral address\n     * @dev can only be called from the owner address\n     * @param _collateral collateral asset address\n     */\n    function blacklistCollateral(address _collateral) external onlyOwner {\n        whitelistedCollateral[_collateral] = false;\n\n        emit CollateralBlacklisted(_collateral);\n    }\n\n    /**\n     * @notice allows the OtokenFactory module to whitelist a new option\n     * @dev can only be called from the OtokenFactory address\n     * @param _otokenAddress oToken\n     */\n    function whitelistOtoken(address _otokenAddress) external onlyFactory {\n        whitelistedOtoken[_otokenAddress] = true;\n\n        emit OtokenWhitelisted(_otokenAddress);\n    }\n\n    /**\n     * @notice allows the owner to blacklist an option\n     * @dev can only be called from the owner address\n     * @param _otokenAddress oToken\n     */\n    function blacklistOtoken(address _otokenAddress) external onlyOwner {\n        whitelistedOtoken[_otokenAddress] = false;\n\n        emit OtokenBlacklisted(_otokenAddress);\n    }\n\n    /**\n     * @notice allows the owner to whitelist a destination address for the call action\n     * @dev can only be called from the owner address\n     * @param _callee callee address\n     */\n    function whitelistCallee(address _callee) external onlyOwner {\n        whitelistedCallee[_callee] = true;\n\n        emit CalleeWhitelisted(_callee);\n    }\n\n    /**\n     * @notice allows the owner to blacklist a destination address for the call action\n     * @dev can only be called from the owner address\n     * @param _callee callee address\n     */\n    function blacklistCallee(address _callee) external onlyOwner {\n        whitelistedCallee[_callee] = false;\n\n        emit CalleeBlacklisted(_callee);\n    }\n}\n"
    },
    "contracts/interfaces/AddressBookInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\ninterface AddressBookInterface {\n    /* Getters */\n\n    function getOtokenImpl() external view returns (address);\n\n    function getOtokenFactory() external view returns (address);\n\n    function getWhitelist() external view returns (address);\n\n    function getController() external view returns (address);\n\n    function getOracle() external view returns (address);\n\n    function getMarginPool() external view returns (address);\n\n    function getMarginCalculator() external view returns (address);\n\n    function getLiquidationManager() external view returns (address);\n\n    function getAddress(bytes32 _id) external view returns (address);\n\n    /* Setters */\n\n    function setOtokenImpl(address _otokenImpl) external;\n\n    function setOtokenFactory(address _factory) external;\n\n    function setOracleImpl(address _otokenImpl) external;\n\n    function setWhitelist(address _whitelist) external;\n\n    function setController(address _controller) external;\n\n    function setMarginPool(address _marginPool) external;\n\n    function setMarginCalculator(address _calculator) external;\n\n    function setLiquidationManager(address _liquidationManager) external;\n\n    function setAddress(bytes32 _id, address _newImpl) external;\n}\n"
    },
    "contracts/tests/OtokenImplV1.sol": {
      "content": "pragma solidity =0.6.10;\n\nimport {ERC20PermitUpgradeable} from \"../packages/oz/upgradeability/erc20-permit/ERC20PermitUpgradeable.sol\";\nimport {AddressBookInterface} from \"../interfaces/AddressBookInterface.sol\";\n\n/**\n * SPDX-License-Identifier: UNLICENSED\n * @dev The Otoken inherits ERC20PermitUpgradeable because we need to use the init instead of constructor\n * This is V1 implementation, with no getOtokenDetails()\n */\ncontract OtokenImplV1 is ERC20PermitUpgradeable {\n    address public addressBook;\n    address public controller;\n    address public underlyingAsset;\n    address public strikeAsset;\n    address public collateralAsset;\n\n    uint256 public strikePrice;\n    uint256 public expiryTimestamp;\n\n    bool public isPut;\n\n    bool public inited = false;\n\n    function init(\n        address _addressBook,\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTimestamp,\n        bool _isPut\n    ) external initializer {\n        inited = true;\n        controller = AddressBookInterface(_addressBook).getController();\n        underlyingAsset = _underlyingAsset;\n        strikeAsset = _strikeAsset;\n        collateralAsset = _collateralAsset;\n        strikePrice = _strikePrice;\n        expiryTimestamp = _expiryTimestamp;\n        isPut = _isPut;\n        string memory tokenName = \"ETHUSDC/1597511955/200P/USDC\";\n        string memory tokenSymbol = \"oETHUSDCP\";\n        __ERC20_init_unchained(tokenName, tokenSymbol);\n        __ERC20Permit_init(tokenName);\n        _setupDecimals(8);\n    }\n\n    function mintOtoken(address _to, uint256 _amount) external {\n        _mint(_to, _amount);\n    }\n\n    function burnOtoken(address account, uint256 amount) external {\n        _burn(account, amount);\n    }\n\n    function getChainId() external view returns (uint256 chainId) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n}\n"
    },
    "contracts/packages/oz/upgradeability/erc20-permit/ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts-upgradeable v3.0.0\n\npragma solidity >=0.6.5 <0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"./IERC20PermitUpgradeable.sol\";\nimport \"../cryptography/ECDSAUpgradeable.sol\";\nimport \"../utils/CountersUpgradeable.sol\";\nimport \"./EIP712Upgradeable.sol\";\nimport \"../Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20PermitUpgradeable is\n    Initializable,\n    ERC20Upgradeable,\n    IERC20PermitUpgradeable,\n    EIP712Upgradeable\n{\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal initializer {\n        __Context_init_unchained();\n        __EIP712_init_unchained(name, \"1\");\n        __ERC20Permit_init_unchained(name);\n    }\n\n    function __ERC20Permit_init_unchained(string memory name) internal initializer {\n        _PERMIT_TYPEHASH = keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n    }\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner].current(), deadline)\n        );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _nonces[owner].increment();\n        _approve(owner, spender, amount);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/packages/oz/upgradeability/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts-upgradeable v3.0.0\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./GSN/ContextUpgradeable.sol\";\nimport \"./IERC20Upgradeable.sol\";\nimport \"./math/SafeMathUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\")\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\")\n        );\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    uint256[44] private __gap;\n}\n"
    },
    "contracts/packages/oz/upgradeability/erc20-permit/IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts-upgradeable v3.0.0\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/packages/oz/upgradeability/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts-upgradeable v3.0.0\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(\n            uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            \"ECDSA: invalid signature 's' value\"\n        );\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "contracts/packages/oz/upgradeability/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts-upgradeable v3.0.0\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../math/SafeMathUpgradeable.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary CountersUpgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    "contracts/packages/oz/upgradeability/erc20-permit/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts-upgradeable v3.0.0\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal initializer {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal initializer {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 name,\n        bytes32 version\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, name, version, _getChainId(), address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", _domainSeparatorV4(), structHash));\n    }\n\n    function _getChainId() private view returns (uint256 chainId) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal view virtual returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal view virtual returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/packages/oz/upgradeability/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts-upgradeable v3.0.0\n\n/* solhint-disable */\npragma solidity >=0.4.24 <0.7.0;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        address self = address(this);\n        uint256 cs;\n        assembly {\n            cs := extcodesize(self)\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/packages/oz/upgradeability/GSN/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts-upgradeable v3.0.0\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {}\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/packages/oz/upgradeability/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts-upgradeable v3.0.0\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/packages/oz/upgradeability/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts-upgradeable v3.0.0\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/mocks/MockPermitERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\nimport {ERC20PermitUpgradeable} from \"../packages/oz/upgradeability/erc20-permit/ERC20PermitUpgradeable.sol\";\n\ncontract MockPermitERC20 is ERC20PermitUpgradeable {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) public {\n        __ERC20_init_unchained(_name, _symbol);\n        __ERC20Permit_init(_name);\n        _setupDecimals(_decimals);\n    }\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n}\n"
    },
    "contracts/mocks/MockOtoken.sol": {
      "content": "pragma solidity =0.6.10;\n\nimport {ERC20PermitUpgradeable} from \"../packages/oz/upgradeability/erc20-permit/ERC20PermitUpgradeable.sol\";\nimport {AddressBookInterface} from \"../interfaces/AddressBookInterface.sol\";\n\n/**\n * SPDX-License-Identifier: UNLICENSED\n * @dev The Otoken inherits ERC20PermitUpgradeable because we need to use the init instead of constructor.\n */\ncontract MockOtoken is ERC20PermitUpgradeable {\n    address public addressBook;\n    address public controller;\n    address public underlyingAsset;\n    address public strikeAsset;\n    address public collateralAsset;\n\n    uint256 public strikePrice;\n    uint256 public expiryTimestamp;\n\n    bool public isPut;\n\n    bool public inited = false;\n\n    function init(\n        address _addressBook,\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTimestamp,\n        bool _isPut\n    ) external initializer {\n        inited = true;\n        controller = AddressBookInterface(_addressBook).getController();\n        underlyingAsset = _underlyingAsset;\n        strikeAsset = _strikeAsset;\n        collateralAsset = _collateralAsset;\n        strikePrice = _strikePrice;\n        expiryTimestamp = _expiryTimestamp;\n        isPut = _isPut;\n        string memory tokenName = \"ETHUSDC/1597511955/200P/USDC\";\n        string memory tokenSymbol = \"oETHUSDCP\";\n        __ERC20_init_unchained(tokenName, tokenSymbol);\n        __ERC20Permit_init(tokenName);\n        _setupDecimals(8);\n    }\n\n    function getOtokenDetails()\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        return (collateralAsset, underlyingAsset, strikeAsset, strikePrice, expiryTimestamp, isPut);\n    }\n\n    function mintOtoken(address _to, uint256 _amount) external {\n        _mint(_to, _amount);\n    }\n\n    function burnOtoken(address account, uint256 amount) external {\n        _burn(account, amount);\n    }\n\n    function getChainId() external view returns (uint256 chainId) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n}\n"
    },
    "contracts/tests/UpgradeableContractV1.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\nimport {Initializable} from \"../packages/oz/upgradeability/Initializable.sol\";\n\n/**\n * @author Opyn Team\n * @notice Upgradeable testing contract\n */\ncontract UpgradeableContractV1 is Initializable {\n    /// @notice addressbook address\n    address public addressBook;\n    /// @notice owner address\n    address public owner;\n\n    /**\n     * @dev this function is invoked by the proxy contract when this contract is added to the\n     * AddressBook.\n     * @param _addressBook the address of the AddressBook\n     **/\n    function initialize(address _addressBook, address _owner) public initializer {\n        addressBook = _addressBook;\n        owner = _owner;\n    }\n\n    function getV1Version() external pure returns (uint256) {\n        return 1;\n    }\n}\n"
    },
    "contracts/tests/UpgradeableContractV2.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\nimport {UpgradeableContractV1} from \"./UpgradeableContractV1.sol\";\n\n/**\n * @author Opyn Team\n * @notice Upgradeable testing contract\n */\ncontract UpgradeableContractV2 is UpgradeableContractV1 {\n    function getV2Version() external pure returns (uint256) {\n        return 2;\n    }\n}\n"
    },
    "contracts/mocks/MockYToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\nimport {ERC20Upgradeable} from \"../packages/oz/upgradeability/ERC20Upgradeable.sol\";\n\ncontract MockYToken is ERC20Upgradeable {\n    uint256 public pricePerShare;\n\n    constructor(string memory _name, string memory _symbol) public {\n        __ERC20_init_unchained(_name, _symbol);\n        _setupDecimals(8);\n    }\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    function setPricePerShare(uint256 _pricePerShare) external {\n        pricePerShare = _pricePerShare;\n    }\n}\n"
    },
    "contracts/mocks/MockWSTETHToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\nimport {ERC20Upgradeable} from \"../packages/oz/upgradeability/ERC20Upgradeable.sol\";\n\ncontract MockWSTETHToken is ERC20Upgradeable {\n    uint256 public stEthPerToken;\n\n    constructor(string memory _name, string memory _symbol) public {\n        __ERC20_init_unchained(_name, _symbol);\n        _setupDecimals(18);\n    }\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    function setStEthPerToken(uint256 _stEthPerToken) external {\n        stEthPerToken = _stEthPerToken;\n    }\n}\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\nimport {ERC20Upgradeable} from \"../packages/oz/upgradeability/ERC20Upgradeable.sol\";\n\ncontract MockERC20 is ERC20Upgradeable {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) public {\n        __ERC20_init_unchained(_name, _symbol);\n        _setupDecimals(_decimals);\n    }\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n}\n"
    },
    "contracts/mocks/MockCUSDC.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\nimport {ERC20Upgradeable} from \"../packages/oz/upgradeability/ERC20Upgradeable.sol\";\nimport {ERC20Interface} from \"../interfaces/ERC20Interface.sol\";\nimport {SafeMath} from \"../packages/oz/SafeMath.sol\";\n\ncontract MockCUSDC is ERC20Upgradeable {\n    uint256 public exchangeRateStored;\n    address public underlying;\n    uint256 public scale = 1e18;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _underlying,\n        uint256 _initExchangeRateStored\n    ) public {\n        __ERC20_init_unchained(_name, _symbol);\n        _setupDecimals(8);\n\n        underlying = _underlying;\n        exchangeRateStored = _initExchangeRateStored;\n    }\n\n    function mint(uint256 amount) public returns (uint256) {\n        uint256 numerator = scale.mul(amount);\n        uint256 cTokenAmount = numerator.div(exchangeRateStored);\n        _mint(msg.sender, cTokenAmount);\n        ERC20Interface(underlying).transferFrom(msg.sender, address(this), amount);\n        return 0;\n    }\n\n    function redeem(uint256 amount) public returns (uint256) {\n        _burn(msg.sender, amount);\n        uint256 underlyingAmount = amount.mul(exchangeRateStored).div(scale);\n        ERC20Interface(underlying).transfer(msg.sender, underlyingAmount);\n    }\n\n    function setExchangeRate(uint256 _exchangeRateStored) external {\n        exchangeRateStored = _exchangeRateStored;\n    }\n}\n"
    },
    "contracts/interfaces/ERC20Interface.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface ERC20Interface {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/packages/oz/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts v3.1.0\n\n/* solhint-disable */\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/pricers/YearnPricer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\nimport {OracleInterface} from \"../interfaces/OracleInterface.sol\";\nimport {OpynPricerInterface} from \"../interfaces/OpynPricerInterface.sol\";\nimport {YearnVaultInterface} from \"../interfaces/YearnVaultInterface.sol\";\nimport {ERC20Interface} from \"../interfaces/ERC20Interface.sol\";\nimport {SafeMath} from \"../packages/oz/SafeMath.sol\";\n\n/**\n * @notice A Pricer contract for a Yearn yToken\n */\ncontract YearnPricer is OpynPricerInterface {\n    using SafeMath for uint256;\n\n    /// @notice opyn oracle address\n    OracleInterface public oracle;\n\n    /// @notice yToken that this pricer will a get price for\n    YearnVaultInterface public yToken;\n\n    /// @notice underlying asset for this yToken\n    ERC20Interface public underlying;\n\n    /**\n     * @param _yToken yToken asset\n     * @param _underlying underlying asset for this yToken\n     * @param _oracle Opyn Oracle contract address\n     */\n    constructor(\n        address _yToken,\n        address _underlying,\n        address _oracle\n    ) public {\n        require(_yToken != address(0), \"YearnPricer: yToken address can not be 0\");\n        require(_underlying != address(0), \"YearnPricer: underlying address can not be 0\");\n        require(_oracle != address(0), \"YearnPricer: oracle address can not be 0\");\n\n        yToken = YearnVaultInterface(_yToken);\n        underlying = ERC20Interface(_underlying);\n        oracle = OracleInterface(_oracle);\n    }\n\n    /**\n     * @notice get the live price for the asset\n     * @dev overrides the getPrice function in OpynPricerInterface\n     * @return price of 1e8 yToken in USD, scaled by 1e8\n     */\n    function getPrice() external view override returns (uint256) {\n        uint256 underlyingPrice = oracle.getPrice(address(underlying));\n        require(underlyingPrice > 0, \"YearnPricer: underlying price is 0\");\n        return _underlyingPriceToYtokenPrice(underlyingPrice);\n    }\n\n    /**\n     * @notice set the expiry price in the oracle\n     * @dev requires that the underlying price has been set before setting a yToken price\n     * @param _expiryTimestamp expiry to set a price for\n     */\n    function setExpiryPriceInOracle(uint256 _expiryTimestamp) external {\n        (uint256 underlyingPriceExpiry, ) = oracle.getExpiryPrice(address(underlying), _expiryTimestamp);\n        require(underlyingPriceExpiry > 0, \"YearnPricer: underlying price not set yet\");\n        uint256 yTokenPrice = _underlyingPriceToYtokenPrice(underlyingPriceExpiry);\n        oracle.setExpiryPrice(address(yToken), _expiryTimestamp, yTokenPrice);\n    }\n\n    /**\n     * @dev convert underlying price to yToken price with the yToken to underlying exchange rate\n     * @param _underlyingPrice price of 1 underlying token (ie 1e6 USDC, 1e18 WETH) in USD, scaled by 1e8\n     * @return price of 1e8 yToken in USD, scaled by 1e8\n     */\n    function _underlyingPriceToYtokenPrice(uint256 _underlyingPrice) private view returns (uint256) {\n        uint256 pricePerShare = yToken.pricePerShare();\n        uint8 underlyingDecimals = underlying.decimals();\n\n        return pricePerShare.mul(_underlyingPrice).div(10**uint256(underlyingDecimals));\n    }\n\n    function getHistoricalPrice(uint80 _roundId) external view override returns (uint256, uint256) {\n        revert(\"YearnPricer: Deprecated\");\n    }\n}\n"
    },
    "contracts/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\ninterface OracleInterface {\n    function isLockingPeriodOver(address _asset, uint256 _expiryTimestamp) external view returns (bool);\n\n    function isDisputePeriodOver(address _asset, uint256 _expiryTimestamp) external view returns (bool);\n\n    function getExpiryPrice(address _asset, uint256 _expiryTimestamp) external view returns (uint256, bool);\n\n    function getDisputer() external view returns (address);\n\n    function getPricer(address _asset) external view returns (address);\n\n    function getPrice(address _asset) external view returns (uint256);\n\n    function getPricerLockingPeriod(address _pricer) external view returns (uint256);\n\n    function getPricerDisputePeriod(address _pricer) external view returns (uint256);\n\n    function getChainlinkRoundData(address _asset, uint80 _roundId) external view returns (uint256, uint256);\n\n    // Non-view function\n\n    function setAssetPricer(address _asset, address _pricer) external;\n\n    function setLockingPeriod(address _pricer, uint256 _lockingPeriod) external;\n\n    function setDisputePeriod(address _pricer, uint256 _disputePeriod) external;\n\n    function setExpiryPrice(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _price\n    ) external;\n\n    function disputeExpiryPrice(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _price\n    ) external;\n\n    function setDisputer(address _disputer) external;\n}\n"
    },
    "contracts/interfaces/OpynPricerInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\ninterface OpynPricerInterface {\n    function getPrice() external view returns (uint256);\n\n    function getHistoricalPrice(uint80 _roundId) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/YearnVaultInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.10;\n\ninterface YearnVaultInterface {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function pricePerShare() external view returns (uint256);\n\n    function deposit(uint256) external;\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/tests/FlashUnwrap.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\npragma experimental ABIEncoderV2;\n\nimport {CalleeInterface} from \"../interfaces/CalleeInterface.sol\";\nimport {ERC20Interface} from \"../interfaces/ERC20Interface.sol\";\nimport {SafeERC20} from \"../packages/oz/SafeERC20.sol\";\nimport {WETH9} from \"../external/canonical-weth/WETH9.sol\";\n\n/**\n * @author Opyn Team\n * @title FlashUnwrap\n * @notice contract To unwrap WETH. This is just a contract to test the Call action\n */\ncontract FlashUnwrap is CalleeInterface {\n    using SafeERC20 for ERC20Interface;\n\n    // Number of bytes in a CallFunctionData struct\n    uint256 private constant NUM_CALLFUNCTIONDATA_BYTES = 32;\n\n    WETH9 public WETH;\n\n    struct CallFunctionData {\n        uint256 amount;\n    }\n\n    constructor(address payable weth) public {\n        WETH = WETH9(weth);\n    }\n\n    event WrappedETH(address indexed to, uint256 amount);\n    event UnwrappedETH(address to, uint256 amount);\n\n    receive() external payable {}\n\n    // flash unwrap\n    function callFunction(address payable _sender, bytes memory _data) external override {\n        require(_data.length == NUM_CALLFUNCTIONDATA_BYTES, \"FlashUnwrap: cannot parse CallFunctionData\");\n\n        CallFunctionData memory cfd = abi.decode(_data, (CallFunctionData));\n\n        WETH.transferFrom(_sender, address(this), cfd.amount);\n        WETH.withdraw(cfd.amount);\n\n        _sender.transfer(cfd.amount);\n\n        emit UnwrappedETH(_sender, cfd.amount);\n    }\n}\n"
    },
    "contracts/interfaces/CalleeInterface.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\n/**\n * @dev Contract interface that can be called from Controller as a call action.\n */\ninterface CalleeInterface {\n    /**\n     * Allows users to send this contract arbitrary data.\n     * @param _sender The msg.sender to Controller\n     * @param _data Arbitrary data given by the sender\n     */\n    function callFunction(address payable _sender, bytes memory _data) external;\n}\n"
    },
    "contracts/packages/oz/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts v3.1.0\n\n/* solhint-disable */\npragma solidity ^0.6.0;\n\nimport \"../../interfaces/ERC20Interface.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20Interface;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        ERC20Interface token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        ERC20Interface token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {ERC20Interface-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        ERC20Interface token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        ERC20Interface token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        ERC20Interface token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\n            value,\n            \"SafeERC20: decreased allowance below zero\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(ERC20Interface token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/external/canonical-weth/WETH9.sol": {
      "content": "// Copyright (C) 2015, 2016, 2017 Dapphub\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n// SPDX-License-Identifier:  GNU GPL\npragma solidity 0.6.10;\n\n/**\n * @title WETH contract\n * @author Opyn Team\n * @dev A wrapper to use ETH as collateral\n */\ncontract WETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    /// @notice emits an event when a sender approves WETH\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    /// @notice emits an event when a sender transfers WETH\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    /// @notice emits an event when a sender deposits ETH into this contract\n    event Deposit(address indexed dst, uint256 wad);\n    /// @notice emits an event when a sender withdraws ETH from this contract\n    event Withdrawal(address indexed src, uint256 wad);\n\n    /// @notice mapping between address and WETH balance\n    mapping(address => uint256) public balanceOf;\n    /// @notice mapping between addresses and allowance amount\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /**\n     * @notice fallback function that receives ETH\n     * @dev will get called in a tx with ETH\n     */\n    receive() external payable {\n        deposit();\n    }\n\n    /**\n     * @notice wrap deposited ETH into WETH\n     */\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    /**\n     * @notice withdraw ETH from contract\n     * @dev Unwrap from WETH to ETH\n     * @param _wad amount WETH to unwrap and withdraw\n     */\n    function withdraw(uint256 _wad) public {\n        require(balanceOf[msg.sender] >= _wad, \"WETH9: insufficient sender balance\");\n        balanceOf[msg.sender] -= _wad;\n        msg.sender.transfer(_wad);\n        emit Withdrawal(msg.sender, _wad);\n    }\n\n    /**\n     * @notice get ETH total supply\n     * @return total supply\n     */\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @notice approve transfer\n     * @param _guy address to approve\n     * @param _wad amount of WETH\n     * @return True if tx succeeds, False if not\n     */\n    function approve(address _guy, uint256 _wad) public returns (bool) {\n        allowance[msg.sender][_guy] = _wad;\n        emit Approval(msg.sender, _guy, _wad);\n        return true;\n    }\n\n    /**\n     * @notice transfer WETH\n     * @param _dst destination address\n     * @param _wad amount to transfer\n     * @return True if tx succeeds, False if not\n     */\n    function transfer(address _dst, uint256 _wad) public returns (bool) {\n        return transferFrom(msg.sender, _dst, _wad);\n    }\n\n    /**\n     * @notice transfer from address\n     * @param _src source address\n     * @param _dst destination address\n     * @param _wad amount to transfer\n     * @return True if tx succeeds, False if not\n     */\n    function transferFrom(\n        address _src,\n        address _dst,\n        uint256 _wad\n    ) public returns (bool) {\n        require(balanceOf[_src] >= _wad, \"WETH9: insufficient source balance\");\n\n        if (_src != msg.sender && allowance[_src][msg.sender] != uint256(-1)) {\n            require(allowance[_src][msg.sender] >= _wad, \"WETH9: invalid allowance\");\n            allowance[_src][msg.sender] -= _wad;\n        }\n\n        balanceOf[_src] -= _wad;\n        balanceOf[_dst] += _wad;\n\n        emit Transfer(_src, _dst, _wad);\n\n        return true;\n    }\n}\n"
    },
    "contracts/packages/oz/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts v3.1.0\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/external/proxies/PayableProxyController.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity =0.6.10;\n\npragma experimental ABIEncoderV2;\n\nimport {WETH9} from \"../canonical-weth/WETH9.sol\";\nimport {ReentrancyGuard} from \"../../packages/oz/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"../../packages/oz/SafeERC20.sol\";\nimport {ERC20Interface} from \"../../interfaces/ERC20Interface.sol\";\nimport {Actions} from \"../../libs/Actions.sol\";\nimport {Controller} from \"../../core/Controller.sol\";\nimport {Address} from \"../../packages/oz/Address.sol\";\n\n/**\n * @title PayableProxyController\n * @author Opyn Team\n * @dev Contract for wrapping/unwrapping ETH before/after interacting with the Gamma Protocol\n */\ncontract PayableProxyController is ReentrancyGuard {\n    using SafeERC20 for ERC20Interface;\n    using Address for address payable;\n\n    WETH9 public weth;\n    Controller public controller;\n\n    constructor(\n        address _controller,\n        address _marginPool,\n        address payable _weth\n    ) public {\n        controller = Controller(_controller);\n        weth = WETH9(_weth);\n        ERC20Interface(address(weth)).safeApprove(_marginPool, uint256(-1));\n    }\n\n    /**\n     * @notice fallback function which disallows ETH to be sent to this contract without data except when unwrapping WETH\n     */\n    fallback() external payable {\n        require(msg.sender == address(weth), \"PayableProxyController: Cannot receive ETH\");\n    }\n\n    /**\n     * @notice execute a number of actions\n     * @dev a wrapper for the Controller operate function, to wrap WETH and the beginning and unwrap WETH at the end of the execution\n     * @param _actions array of actions arguments\n     * @param _sendEthTo address to send the remaining eth to\n     */\n    function operate(Actions.ActionArgs[] memory _actions, address payable _sendEthTo) external payable nonReentrant {\n        // create WETH from ETH\n        if (msg.value != 0) {\n            weth.deposit{value: msg.value}();\n        }\n\n        // verify sender\n        for (uint256 i = 0; i < _actions.length; i++) {\n            Actions.ActionArgs memory action = _actions[i];\n\n            // check that msg.sender is an owner or operator\n            if (action.owner != address(0)) {\n                require(\n                    (msg.sender == action.owner) || (controller.isOperator(action.owner, msg.sender)),\n                    \"PayableProxyController: cannot execute action \"\n                );\n            }\n\n            if (action.actionType == Actions.ActionType.Call) {\n                // our PayableProxy could ends up approving amount > total eth received.\n                ERC20Interface(address(weth)).safeIncreaseAllowance(action.secondAddress, msg.value);\n            }\n        }\n\n        controller.operate(_actions);\n\n        // return all remaining WETH to the sendEthTo address as ETH\n        uint256 remainingWeth = weth.balanceOf(address(this));\n        if (remainingWeth != 0) {\n            require(_sendEthTo != address(0), \"PayableProxyController: cannot send ETH to address zero\");\n\n            weth.withdraw(remainingWeth);\n            _sendEthTo.sendValue(remainingWeth);\n        }\n    }\n}\n"
    },
    "contracts/packages/oz/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts v3.1.0\n\npragma solidity =0.6.10;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/libs/Actions.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\nimport {MarginVault} from \"./MarginVault.sol\";\n\n/**\n * @title Actions\n * @author Opyn Team\n * @notice A library that provides a ActionArgs struct, sub types of Action structs, and functions to parse ActionArgs into specific Actions.\n * errorCode\n * A1 can only parse arguments for open vault actions\n * A2 cannot open vault for an invalid account\n * A3 cannot open vault with an invalid type\n * A4 can only parse arguments for mint actions\n * A5 cannot mint from an invalid account\n * A6 can only parse arguments for burn actions\n * A7 cannot burn from an invalid account\n * A8 can only parse arguments for deposit actions\n * A9 cannot deposit to an invalid account\n * A10 can only parse arguments for withdraw actions\n * A11 cannot withdraw from an invalid account\n * A12 cannot withdraw to an invalid account\n * A13 can only parse arguments for redeem actions\n * A14 cannot redeem to an invalid account\n * A15 can only parse arguments for settle vault actions\n * A16 cannot settle vault for an invalid account\n * A17 cannot withdraw payout to an invalid account\n * A18 can only parse arguments for liquidate action\n * A19 cannot liquidate vault for an invalid account owner\n * A20 cannot send collateral to an invalid account\n * A21 cannot parse liquidate action with no round id\n * A22 can only parse arguments for call actions\n * A23 target address cannot be address(0)\n */\nlibrary Actions {\n    // possible actions that can be performed\n    enum ActionType {\n        OpenVault,\n        MintShortOption,\n        BurnShortOption,\n        DepositLongOption,\n        WithdrawLongOption,\n        DepositCollateral,\n        WithdrawCollateral,\n        SettleVault,\n        Redeem,\n        Call,\n        Liquidate\n    }\n\n    struct ActionArgs {\n        // type of action that is being performed on the system\n        ActionType actionType;\n        // address of the account owner\n        address owner;\n        // address which we move assets from or to (depending on the action type)\n        address secondAddress;\n        // asset that is to be transfered\n        address asset;\n        // index of the vault that is to be modified (if any)\n        uint256 vaultId;\n        // amount of asset that is to be transfered\n        uint256 amount;\n        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n        uint256 index;\n        // any other data that needs to be passed in for arbitrary function calls\n        bytes data;\n    }\n\n    struct MintArgs {\n        // address of the account owner\n        address owner;\n        // index of the vault from which the asset will be minted\n        uint256 vaultId;\n        // address to which we transfer the minted oTokens\n        address to;\n        // oToken that is to be minted\n        address otoken;\n        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n        uint256 index;\n        // amount of oTokens that is to be minted\n        uint256 amount;\n    }\n\n    struct BurnArgs {\n        // address of the account owner\n        address owner;\n        // index of the vault from which the oToken will be burned\n        uint256 vaultId;\n        // address from which we transfer the oTokens\n        address from;\n        // oToken that is to be burned\n        address otoken;\n        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n        uint256 index;\n        // amount of oTokens that is to be burned\n        uint256 amount;\n    }\n\n    struct OpenVaultArgs {\n        // address of the account owner\n        address owner;\n        // vault id to create\n        uint256 vaultId;\n        // vault type, 0 for spread/max loss and 1 for naked margin vault\n        uint256 vaultType;\n    }\n\n    struct DepositArgs {\n        // address of the account owner\n        address owner;\n        // index of the vault to which the asset will be added\n        uint256 vaultId;\n        // address from which we transfer the asset\n        address from;\n        // asset that is to be deposited\n        address asset;\n        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n        uint256 index;\n        // amount of asset that is to be deposited\n        uint256 amount;\n    }\n\n    struct RedeemArgs {\n        // address to which we pay out the oToken proceeds\n        address receiver;\n        // oToken that is to be redeemed\n        address otoken;\n        // amount of oTokens that is to be redeemed\n        uint256 amount;\n    }\n\n    struct WithdrawArgs {\n        // address of the account owner\n        address owner;\n        // index of the vault from which the asset will be withdrawn\n        uint256 vaultId;\n        // address to which we transfer the asset\n        address to;\n        // asset that is to be withdrawn\n        address asset;\n        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n        uint256 index;\n        // amount of asset that is to be withdrawn\n        uint256 amount;\n    }\n\n    struct SettleVaultArgs {\n        // address of the account owner\n        address owner;\n        // index of the vault to which is to be settled\n        uint256 vaultId;\n        // address to which we transfer the remaining collateral\n        address to;\n    }\n\n    struct LiquidateArgs {\n        // address of the vault owner to liquidate\n        address owner;\n        // address of the liquidated collateral receiver\n        address receiver;\n        // vault id to liquidate\n        uint256 vaultId;\n        // amount of debt(otoken) to repay\n        uint256 amount;\n        // chainlink round id\n        uint256 roundId;\n    }\n\n    struct CallArgs {\n        // address of the callee contract\n        address callee;\n        // data field for external calls\n        bytes data;\n    }\n\n    /**\n     * @notice parses the passed in action arguments to get the arguments for an open vault action\n     * @param _args general action arguments structure\n     * @return arguments for a open vault action\n     */\n    function _parseOpenVaultArgs(ActionArgs memory _args) internal pure returns (OpenVaultArgs memory) {\n        require(_args.actionType == ActionType.OpenVault, \"A1\");\n        require(_args.owner != address(0), \"A2\");\n\n        // if not _args.data included, vault type will be 0 by default\n        uint256 vaultType;\n\n        if (_args.data.length == 32) {\n            // decode vault type from _args.data\n            vaultType = abi.decode(_args.data, (uint256));\n        }\n\n        // for now we only have 2 vault types\n        require(vaultType < 2, \"A3\");\n\n        return OpenVaultArgs({owner: _args.owner, vaultId: _args.vaultId, vaultType: vaultType});\n    }\n\n    /**\n     * @notice parses the passed in action arguments to get the arguments for a mint action\n     * @param _args general action arguments structure\n     * @return arguments for a mint action\n     */\n    function _parseMintArgs(ActionArgs memory _args) internal pure returns (MintArgs memory) {\n        require(_args.actionType == ActionType.MintShortOption, \"A4\");\n        require(_args.owner != address(0), \"A5\");\n\n        return\n            MintArgs({\n                owner: _args.owner,\n                vaultId: _args.vaultId,\n                to: _args.secondAddress,\n                otoken: _args.asset,\n                index: _args.index,\n                amount: _args.amount\n            });\n    }\n\n    /**\n     * @notice parses the passed in action arguments to get the arguments for a burn action\n     * @param _args general action arguments structure\n     * @return arguments for a burn action\n     */\n    function _parseBurnArgs(ActionArgs memory _args) internal pure returns (BurnArgs memory) {\n        require(_args.actionType == ActionType.BurnShortOption, \"A6\");\n        require(_args.owner != address(0), \"A7\");\n\n        return\n            BurnArgs({\n                owner: _args.owner,\n                vaultId: _args.vaultId,\n                from: _args.secondAddress,\n                otoken: _args.asset,\n                index: _args.index,\n                amount: _args.amount\n            });\n    }\n\n    /**\n     * @notice parses the passed in action arguments to get the arguments for a deposit action\n     * @param _args general action arguments structure\n     * @return arguments for a deposit action\n     */\n    function _parseDepositArgs(ActionArgs memory _args) internal pure returns (DepositArgs memory) {\n        require(\n            (_args.actionType == ActionType.DepositLongOption) || (_args.actionType == ActionType.DepositCollateral),\n            \"A8\"\n        );\n        require(_args.owner != address(0), \"A9\");\n\n        return\n            DepositArgs({\n                owner: _args.owner,\n                vaultId: _args.vaultId,\n                from: _args.secondAddress,\n                asset: _args.asset,\n                index: _args.index,\n                amount: _args.amount\n            });\n    }\n\n    /**\n     * @notice parses the passed in action arguments to get the arguments for a withdraw action\n     * @param _args general action arguments structure\n     * @return arguments for a withdraw action\n     */\n    function _parseWithdrawArgs(ActionArgs memory _args) internal pure returns (WithdrawArgs memory) {\n        require(\n            (_args.actionType == ActionType.WithdrawLongOption) || (_args.actionType == ActionType.WithdrawCollateral),\n            \"A10\"\n        );\n        require(_args.owner != address(0), \"A11\");\n        require(_args.secondAddress != address(0), \"A12\");\n\n        return\n            WithdrawArgs({\n                owner: _args.owner,\n                vaultId: _args.vaultId,\n                to: _args.secondAddress,\n                asset: _args.asset,\n                index: _args.index,\n                amount: _args.amount\n            });\n    }\n\n    /**\n     * @notice parses the passed in action arguments to get the arguments for an redeem action\n     * @param _args general action arguments structure\n     * @return arguments for a redeem action\n     */\n    function _parseRedeemArgs(ActionArgs memory _args) internal pure returns (RedeemArgs memory) {\n        require(_args.actionType == ActionType.Redeem, \"A13\");\n        require(_args.secondAddress != address(0), \"A14\");\n\n        return RedeemArgs({receiver: _args.secondAddress, otoken: _args.asset, amount: _args.amount});\n    }\n\n    /**\n     * @notice parses the passed in action arguments to get the arguments for a settle vault action\n     * @param _args general action arguments structure\n     * @return arguments for a settle vault action\n     */\n    function _parseSettleVaultArgs(ActionArgs memory _args) internal pure returns (SettleVaultArgs memory) {\n        require(_args.actionType == ActionType.SettleVault, \"A15\");\n        require(_args.owner != address(0), \"A16\");\n        require(_args.secondAddress != address(0), \"A17\");\n\n        return SettleVaultArgs({owner: _args.owner, vaultId: _args.vaultId, to: _args.secondAddress});\n    }\n\n    function _parseLiquidateArgs(ActionArgs memory _args) internal pure returns (LiquidateArgs memory) {\n        require(_args.actionType == ActionType.Liquidate, \"A18\");\n        require(_args.owner != address(0), \"A19\");\n        require(_args.secondAddress != address(0), \"A20\");\n        require(_args.data.length == 32, \"A21\");\n\n        // decode chainlink round id from _args.data\n        uint256 roundId = abi.decode(_args.data, (uint256));\n\n        return\n            LiquidateArgs({\n                owner: _args.owner,\n                receiver: _args.secondAddress,\n                vaultId: _args.vaultId,\n                amount: _args.amount,\n                roundId: roundId\n            });\n    }\n\n    /**\n     * @notice parses the passed in action arguments to get the arguments for a call action\n     * @param _args general action arguments structure\n     * @return arguments for a call action\n     */\n    function _parseCallArgs(ActionArgs memory _args) internal pure returns (CallArgs memory) {\n        require(_args.actionType == ActionType.Call, \"A22\");\n        require(_args.secondAddress != address(0), \"A23\");\n\n        return CallArgs({callee: _args.secondAddress, data: _args.data});\n    }\n}\n"
    },
    "contracts/core/Controller.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity =0.6.10;\n\npragma experimental ABIEncoderV2;\n\nimport {OwnableUpgradeSafe} from \"../packages/oz/upgradeability/OwnableUpgradeSafe.sol\";\nimport {ReentrancyGuardUpgradeSafe} from \"../packages/oz/upgradeability/ReentrancyGuardUpgradeSafe.sol\";\nimport {Initializable} from \"../packages/oz/upgradeability/Initializable.sol\";\nimport {SafeMath} from \"../packages/oz/SafeMath.sol\";\nimport {MarginVault} from \"../libs/MarginVault.sol\";\nimport {Actions} from \"../libs/Actions.sol\";\nimport {AddressBookInterface} from \"../interfaces/AddressBookInterface.sol\";\nimport {OtokenInterface} from \"../interfaces/OtokenInterface.sol\";\nimport {MarginCalculatorInterface} from \"../interfaces/MarginCalculatorInterface.sol\";\nimport {OracleInterface} from \"../interfaces/OracleInterface.sol\";\nimport {WhitelistInterface} from \"../interfaces/WhitelistInterface.sol\";\nimport {MarginPoolInterface} from \"../interfaces/MarginPoolInterface.sol\";\nimport {CalleeInterface} from \"../interfaces/CalleeInterface.sol\";\n\n/**\n * Controller Error Codes\n * C1: sender is not full pauser\n * C2: sender is not partial pauser\n * C3: callee is not a whitelisted address\n * C4: system is partially paused\n * C5: system is fully paused\n * C6: msg.sender is not authorized to run action\n * C7: invalid addressbook address\n * C8: invalid owner address\n * C9: invalid input\n * C10: fullPauser cannot be set to address zero\n * C11: partialPauser cannot be set to address zero\n * C12: can not run actions for different owners\n * C13: can not run actions on different vaults\n * C14: invalid final vault state\n * C15: can not run actions on inexistent vault\n * C16: cannot deposit long otoken from this address\n * C17: otoken is not whitelisted to be used as collateral\n * C18: otoken used as collateral is already expired\n * C19: can not withdraw an expired otoken\n * C20: cannot deposit collateral from this address\n * C21: asset is not whitelisted to be used as collateral\n * C22: can not withdraw collateral from a vault with an expired short otoken\n * C23: otoken is not whitelisted to be minted\n * C24: can not mint expired otoken\n * C25: cannot burn from this address\n * C26: can not burn expired otoken\n * C27: otoken is not whitelisted to be redeemed\n * C28: can not redeem un-expired otoken\n * C29: asset prices not finalized yet\n * C30: can't settle vault with no otoken\n * C31: can not settle vault with un-expired otoken\n * C32: can not settle undercollateralized vault\n * C33: can not liquidate vault\n * C34: can not leave less than collateral dust\n * C35: invalid vault id\n * C36: cap amount should be greater than zero\n * C37: collateral exceed naked margin cap\n */\n\n/**\n * @title Controller\n * @author Opyn Team\n * @notice Contract that controls the Gamma Protocol and the interaction of all sub contracts\n */\ncontract Controller is Initializable, OwnableUpgradeSafe, ReentrancyGuardUpgradeSafe {\n    using MarginVault for MarginVault.Vault;\n    using SafeMath for uint256;\n\n    AddressBookInterface public addressbook;\n    WhitelistInterface public whitelist;\n    OracleInterface public oracle;\n    MarginCalculatorInterface public calculator;\n    MarginPoolInterface public pool;\n\n    ///@dev scale used in MarginCalculator\n    uint256 internal constant BASE = 8;\n\n    /// @notice address that has permission to partially pause the system, where system functionality is paused\n    /// except redeem and settleVault\n    address public partialPauser;\n\n    /// @notice address that has permission to fully pause the system, where all system functionality is paused\n    address public fullPauser;\n\n    /// @notice True if all system functionality is paused other than redeem and settle vault\n    bool public systemPartiallyPaused;\n\n    /// @notice True if all system functionality is paused\n    bool public systemFullyPaused;\n\n    /// @notice True if a call action can only be executed to a whitelisted callee\n    bool public callRestricted;\n\n    /// @dev mapping between an owner address and the number of owner address vaults\n    mapping(address => uint256) internal accountVaultCounter;\n    /// @dev mapping between an owner address and a specific vault using a vault id\n    mapping(address => mapping(uint256 => MarginVault.Vault)) internal vaults;\n    /// @dev mapping between an account owner and their approved or unapproved account operators\n    mapping(address => mapping(address => bool)) internal operators;\n\n    /******************************************************************** V2.0.0 storage upgrade ******************************************************/\n\n    /// @dev mapping to map vault by each vault type, naked margin vault should be set to 1, spread/max loss vault should be set to 0\n    mapping(address => mapping(uint256 => uint256)) internal vaultType;\n    /// @dev mapping to store the timestamp at which the vault was last updated, will be updated in every action that changes the vault state or when calling sync()\n    mapping(address => mapping(uint256 => uint256)) internal vaultLatestUpdate;\n\n    /// @dev mapping to store cap amount for naked margin vault per options collateral asset (scaled by collateral asset decimals)\n    mapping(address => uint256) internal nakedCap;\n\n    /// @dev mapping to store amount of naked margin vaults in pool\n    mapping(address => uint256) internal nakedPoolBalance;\n\n    /// @notice emits an event when an account operator is updated for a specific account owner\n    event AccountOperatorUpdated(address indexed accountOwner, address indexed operator, bool isSet);\n    /// @notice emits an event when a new vault is opened\n    event VaultOpened(address indexed accountOwner, uint256 vaultId, uint256 indexed vaultType);\n    /// @notice emits an event when a long oToken is deposited into a vault\n    event LongOtokenDeposited(\n        address indexed otoken,\n        address indexed accountOwner,\n        address indexed from,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a long oToken is withdrawn from a vault\n    event LongOtokenWithdrawed(\n        address indexed otoken,\n        address indexed AccountOwner,\n        address indexed to,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a collateral asset is deposited into a vault\n    event CollateralAssetDeposited(\n        address indexed asset,\n        address indexed accountOwner,\n        address indexed from,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a collateral asset is withdrawn from a vault\n    event CollateralAssetWithdrawed(\n        address indexed asset,\n        address indexed AccountOwner,\n        address indexed to,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a short oToken is minted from a vault\n    event ShortOtokenMinted(\n        address indexed otoken,\n        address indexed AccountOwner,\n        address indexed to,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a short oToken is burned\n    event ShortOtokenBurned(\n        address indexed otoken,\n        address indexed AccountOwner,\n        address indexed from,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when an oToken is redeemed\n    event Redeem(\n        address indexed otoken,\n        address indexed redeemer,\n        address indexed receiver,\n        address collateralAsset,\n        uint256 otokenBurned,\n        uint256 payout\n    );\n    /// @notice emits an event when a vault is settled\n    event VaultSettled(\n        address indexed accountOwner,\n        address indexed oTokenAddress,\n        address to,\n        uint256 payout,\n        uint256 vaultId,\n        uint256 indexed vaultType\n    );\n    /// @notice emits an event when a vault is liquidated\n    event VaultLiquidated(\n        address indexed liquidator,\n        address indexed receiver,\n        address indexed vaultOwner,\n        uint256 auctionPrice,\n        uint256 auctionStartingRound,\n        uint256 collateralPayout,\n        uint256 debtAmount,\n        uint256 vaultId\n    );\n    /// @notice emits an event when a call action is executed\n    event CallExecuted(address indexed from, address indexed to, bytes data);\n    /// @notice emits an event when the fullPauser address changes\n    event FullPauserUpdated(address indexed oldFullPauser, address indexed newFullPauser);\n    /// @notice emits an event when the partialPauser address changes\n    event PartialPauserUpdated(address indexed oldPartialPauser, address indexed newPartialPauser);\n    /// @notice emits an event when the system partial paused status changes\n    event SystemPartiallyPaused(bool isPaused);\n    /// @notice emits an event when the system fully paused status changes\n    event SystemFullyPaused(bool isPaused);\n    /// @notice emits an event when the call action restriction changes\n    event CallRestricted(bool isRestricted);\n    /// @notice emits an event when a donation transfer executed\n    event Donated(address indexed donator, address indexed asset, uint256 amount);\n    /// @notice emits an event when naked cap is updated\n    event NakedCapUpdated(address indexed collateral, uint256 cap);\n\n    /**\n     * @notice modifier to check if the system is not partially paused, where only redeem and settleVault is allowed\n     */\n    modifier notPartiallyPaused() {\n        _isNotPartiallyPaused();\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if the system is not fully paused, where no functionality is allowed\n     */\n    modifier notFullyPaused() {\n        _isNotFullyPaused();\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if sender is the fullPauser address\n     */\n    modifier onlyFullPauser() {\n        require(msg.sender == fullPauser, \"C1\");\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if the sender is the partialPauser address\n     */\n    modifier onlyPartialPauser() {\n        require(msg.sender == partialPauser, \"C2\");\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if the sender is the account owner or an approved account operator\n     * @param _sender sender address\n     * @param _accountOwner account owner address\n     */\n    modifier onlyAuthorized(address _sender, address _accountOwner) {\n        _isAuthorized(_sender, _accountOwner);\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if the called address is a whitelisted callee address\n     * @param _callee called address\n     */\n    modifier onlyWhitelistedCallee(address _callee) {\n        if (callRestricted) {\n            require(_isCalleeWhitelisted(_callee), \"C3\");\n        }\n\n        _;\n    }\n\n    /**\n     * @dev check if the system is not in a partiallyPaused state\n     */\n    function _isNotPartiallyPaused() internal view {\n        require(!systemPartiallyPaused, \"C4\");\n    }\n\n    /**\n     * @dev check if the system is not in an fullyPaused state\n     */\n    function _isNotFullyPaused() internal view {\n        require(!systemFullyPaused, \"C5\");\n    }\n\n    /**\n     * @dev check if the sender is an authorized operator\n     * @param _sender msg.sender\n     * @param _accountOwner owner of a vault\n     */\n    function _isAuthorized(address _sender, address _accountOwner) internal view {\n        require((_sender == _accountOwner) || (operators[_accountOwner][_sender]), \"C6\");\n    }\n\n    /**\n     * @notice initalize the deployed contract\n     * @param _addressBook addressbook module\n     * @param _owner account owner address\n     */\n    function initialize(address _addressBook, address _owner) external initializer {\n        require(_addressBook != address(0), \"C7\");\n        require(_owner != address(0), \"C8\");\n\n        __Ownable_init(_owner);\n        __ReentrancyGuard_init_unchained();\n\n        addressbook = AddressBookInterface(_addressBook);\n        _refreshConfigInternal();\n\n        callRestricted = true;\n    }\n\n    /**\n     * @notice send asset amount to margin pool\n     * @dev use donate() instead of direct transfer() to store the balance in assetBalance\n     * @param _asset asset address\n     * @param _amount amount to donate to pool\n     */\n    function donate(address _asset, uint256 _amount) external {\n        pool.transferToPool(_asset, msg.sender, _amount);\n\n        emit Donated(msg.sender, _asset, _amount);\n    }\n\n    /**\n     * @notice allows the partialPauser to toggle the systemPartiallyPaused variable and partially pause or partially unpause the system\n     * @dev can only be called by the partialPauser\n     * @param _partiallyPaused new boolean value to set systemPartiallyPaused to\n     */\n    function setSystemPartiallyPaused(bool _partiallyPaused) external onlyPartialPauser {\n        require(systemPartiallyPaused != _partiallyPaused, \"C9\");\n\n        systemPartiallyPaused = _partiallyPaused;\n\n        emit SystemPartiallyPaused(systemPartiallyPaused);\n    }\n\n    /**\n     * @notice allows the fullPauser to toggle the systemFullyPaused variable and fully pause or fully unpause the system\n     * @dev can only be called by the fullyPauser\n     * @param _fullyPaused new boolean value to set systemFullyPaused to\n     */\n    function setSystemFullyPaused(bool _fullyPaused) external onlyFullPauser {\n        require(systemFullyPaused != _fullyPaused, \"C9\");\n\n        systemFullyPaused = _fullyPaused;\n\n        emit SystemFullyPaused(systemFullyPaused);\n    }\n\n    /**\n     * @notice allows the owner to set the fullPauser address\n     * @dev can only be called by the owner\n     * @param _fullPauser new fullPauser address\n     */\n    function setFullPauser(address _fullPauser) external onlyOwner {\n        require(_fullPauser != address(0), \"C10\");\n        require(fullPauser != _fullPauser, \"C9\");\n        emit FullPauserUpdated(fullPauser, _fullPauser);\n        fullPauser = _fullPauser;\n    }\n\n    /**\n     * @notice allows the owner to set the partialPauser address\n     * @dev can only be called by the owner\n     * @param _partialPauser new partialPauser address\n     */\n    function setPartialPauser(address _partialPauser) external onlyOwner {\n        require(_partialPauser != address(0), \"C11\");\n        require(partialPauser != _partialPauser, \"C9\");\n        emit PartialPauserUpdated(partialPauser, _partialPauser);\n        partialPauser = _partialPauser;\n    }\n\n    /**\n     * @notice allows the owner to toggle the restriction on whitelisted call actions and only allow whitelisted\n     * call addresses or allow any arbitrary call addresses\n     * @dev can only be called by the owner\n     * @param _isRestricted new call restriction state\n     */\n    function setCallRestriction(bool _isRestricted) external onlyOwner {\n        require(callRestricted != _isRestricted, \"C9\");\n\n        callRestricted = _isRestricted;\n\n        emit CallRestricted(callRestricted);\n    }\n\n    /**\n     * @notice allows a user to give or revoke privileges to an operator which can act on their behalf on their vaults\n     * @dev can only be updated by the vault owner\n     * @param _operator operator that the sender wants to give privileges to or revoke them from\n     * @param _isOperator new boolean value that expresses if the sender is giving or revoking privileges for _operator\n     */\n    function setOperator(address _operator, bool _isOperator) external {\n        require(operators[msg.sender][_operator] != _isOperator, \"C9\");\n\n        operators[msg.sender][_operator] = _isOperator;\n\n        emit AccountOperatorUpdated(msg.sender, _operator, _isOperator);\n    }\n\n    /**\n     * @dev updates the configuration of the controller. can only be called by the owner\n     */\n    function refreshConfiguration() external onlyOwner {\n        _refreshConfigInternal();\n    }\n\n    /**\n     * @notice set cap amount for collateral asset used in naked margin\n     * @dev can only be called by owner\n     * @param _collateral collateral asset address\n     * @param _cap cap amount, should be scaled by collateral asset decimals\n     */\n    function setNakedCap(address _collateral, uint256 _cap) external onlyOwner {\n        require(_cap > 0, \"C36\");\n\n        nakedCap[_collateral] = _cap;\n\n        emit NakedCapUpdated(_collateral, _cap);\n    }\n\n    /**\n     * @notice execute a number of actions on specific vaults\n     * @dev can only be called when the system is not fully paused\n     * @param _actions array of actions arguments\n     */\n    function operate(Actions.ActionArgs[] memory _actions) external nonReentrant notFullyPaused {\n        (bool vaultUpdated, address vaultOwner, uint256 vaultId) = _runActions(_actions);\n        if (vaultUpdated) {\n            _verifyFinalState(vaultOwner, vaultId);\n            vaultLatestUpdate[vaultOwner][vaultId] = now;\n        }\n    }\n\n    /**\n     * @notice sync vault latest update timestamp\n     * @dev anyone can update the latest time the vault was touched by calling this function\n     * vaultLatestUpdate will sync if the vault is well collateralized\n     * @param _owner vault owner address\n     * @param _vaultId vault id\n     */\n    function sync(address _owner, uint256 _vaultId) external nonReentrant notFullyPaused {\n        _verifyFinalState(_owner, _vaultId);\n        vaultLatestUpdate[_owner][_vaultId] = now;\n    }\n\n    /**\n     * @notice check if a specific address is an operator for an owner account\n     * @param _owner account owner address\n     * @param _operator account operator address\n     * @return True if the _operator is an approved operator for the _owner account\n     */\n    function isOperator(address _owner, address _operator) external view returns (bool) {\n        return operators[_owner][_operator];\n    }\n\n    /**\n     * @notice returns the current controller configuration\n     * @return whitelist, the address of the whitelist module\n     * @return oracle, the address of the oracle module\n     * @return calculator, the address of the calculator module\n     * @return pool, the address of the pool module\n     */\n    function getConfiguration()\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            address\n        )\n    {\n        return (address(whitelist), address(oracle), address(calculator), address(pool));\n    }\n\n    /**\n     * @notice return a vault's proceeds pre or post expiry, the amount of collateral that can be removed from a vault\n     * @param _owner account owner of the vault\n     * @param _vaultId vaultId to return balances for\n     * @return amount of collateral that can be taken out\n     */\n    function getProceed(address _owner, uint256 _vaultId) external view returns (uint256) {\n        (MarginVault.Vault memory vault, uint256 typeVault, ) = getVaultWithDetails(_owner, _vaultId);\n\n        (uint256 netValue, bool isExcess) = calculator.getExcessCollateral(vault, typeVault);\n\n        if (!isExcess) return 0;\n\n        return netValue;\n    }\n\n    /**\n     * @notice check if a vault is liquidatable in a specific round id\n     * @param _owner vault owner address\n     * @param _vaultId vault id to check\n     * @param _roundId chainlink round id to check vault status at\n     * @return isUnderCollat, true if vault is undercollateralized, the price of 1 repaid otoken and the otoken collateral dust amount\n     */\n    function isLiquidatable(\n        address _owner,\n        uint256 _vaultId,\n        uint256 _roundId\n    )\n        external\n        view\n        returns (\n            bool,\n            uint256,\n            uint256\n        )\n    {\n        (, bool isUnderCollat, uint256 price, uint256 dust) = _isLiquidatable(_owner, _vaultId, _roundId);\n        return (isUnderCollat, price, dust);\n    }\n\n    /**\n     * @notice get an oToken's payout/cash value after expiry, in the collateral asset\n     * @param _otoken oToken address\n     * @param _amount amount of the oToken to calculate the payout for, always represented in 1e8\n     * @return amount of collateral to pay out\n     */\n    function getPayout(address _otoken, uint256 _amount) public view returns (uint256) {\n        return calculator.getExpiredPayoutRate(_otoken).mul(_amount).div(10**BASE);\n    }\n\n    /**\n     * @dev return if an expired oToken is ready to be settled, only true when price for underlying,\n     * strike and collateral assets at this specific expiry is available in our Oracle module\n     * @param _otoken oToken\n     */\n    function isSettlementAllowed(address _otoken) external view returns (bool) {\n        (address underlying, address strike, address collateral, uint256 expiry) = _getOtokenDetails(_otoken);\n        return _canSettleAssets(underlying, strike, collateral, expiry);\n    }\n\n    /**\n     * @dev return if underlying, strike, collateral are all allowed to be settled\n     * @param _underlying oToken underlying asset\n     * @param _strike oToken strike asset\n     * @param _collateral oToken collateral asset\n     * @param _expiry otoken expiry timestamp\n     * @return True if the oToken has expired AND all oracle prices at the expiry timestamp have been finalized, False if not\n     */\n    function canSettleAssets(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        uint256 _expiry\n    ) external view returns (bool) {\n        return _canSettleAssets(_underlying, _strike, _collateral, _expiry);\n    }\n\n    /**\n     * @notice get the number of vaults for a specified account owner\n     * @param _accountOwner account owner address\n     * @return number of vaults\n     */\n    function getAccountVaultCounter(address _accountOwner) external view returns (uint256) {\n        return accountVaultCounter[_accountOwner];\n    }\n\n    /**\n     * @notice check if an oToken has expired\n     * @param _otoken oToken address\n     * @return True if the otoken has expired, False if not\n     */\n    function hasExpired(address _otoken) external view returns (bool) {\n        return now >= OtokenInterface(_otoken).expiryTimestamp();\n    }\n\n    /**\n     * @notice return a specific vault\n     * @param _owner account owner\n     * @param _vaultId vault id of vault to return\n     * @return Vault struct that corresponds to the _vaultId of _owner\n     */\n    function getVault(address _owner, uint256 _vaultId) external view returns (MarginVault.Vault memory) {\n        return (vaults[_owner][_vaultId]);\n    }\n\n    /**\n     * @notice return a specific vault\n     * @param _owner account owner\n     * @param _vaultId vault id of vault to return\n     * @return Vault struct that corresponds to the _vaultId of _owner, vault type and the latest timestamp when the vault was updated\n     */\n    function getVaultWithDetails(address _owner, uint256 _vaultId)\n        public\n        view\n        returns (\n            MarginVault.Vault memory,\n            uint256,\n            uint256\n        )\n    {\n        return (vaults[_owner][_vaultId], vaultType[_owner][_vaultId], vaultLatestUpdate[_owner][_vaultId]);\n    }\n\n    /**\n     * @notice get cap amount for collateral asset\n     * @param _asset collateral asset address\n     * @return cap amount\n     */\n    function getNakedCap(address _asset) external view returns (uint256) {\n        return nakedCap[_asset];\n    }\n\n    /**\n     * @notice get amount of collateral deposited in all naked margin vaults\n     * @param _asset collateral asset address\n     * @return naked pool balance\n     */\n    function getNakedPoolBalance(address _asset) external view returns (uint256) {\n        return nakedPoolBalance[_asset];\n    }\n\n    /**\n     * @notice execute a variety of actions\n     * @dev for each action in the action array, execute the corresponding action, only one vault can be modified\n     * for all actions except SettleVault, Redeem, and Call\n     * @param _actions array of type Actions.ActionArgs[], which expresses which actions the user wants to execute\n     * @return vaultUpdated, indicates if a vault has changed\n     * @return owner, the vault owner if a vault has changed\n     * @return vaultId, the vault Id if a vault has changed\n     */\n    function _runActions(Actions.ActionArgs[] memory _actions)\n        internal\n        returns (\n            bool,\n            address,\n            uint256\n        )\n    {\n        address vaultOwner;\n        uint256 vaultId;\n        bool vaultUpdated;\n\n        for (uint256 i = 0; i < _actions.length; i++) {\n            Actions.ActionArgs memory action = _actions[i];\n            Actions.ActionType actionType = action.actionType;\n\n            // actions except Settle, Redeem, Liquidate and Call are \"Vault-updating actinos\"\n            // only allow update 1 vault in each operate call\n            if (\n                (actionType != Actions.ActionType.SettleVault) &&\n                (actionType != Actions.ActionType.Redeem) &&\n                (actionType != Actions.ActionType.Liquidate) &&\n                (actionType != Actions.ActionType.Call)\n            ) {\n                // check if this action is manipulating the same vault as all other actions, if a vault has already been updated\n                if (vaultUpdated) {\n                    require(vaultOwner == action.owner, \"C12\");\n                    require(vaultId == action.vaultId, \"C13\");\n                }\n                vaultUpdated = true;\n                vaultId = action.vaultId;\n                vaultOwner = action.owner;\n            }\n\n            if (actionType == Actions.ActionType.OpenVault) {\n                _openVault(Actions._parseOpenVaultArgs(action));\n            } else if (actionType == Actions.ActionType.DepositLongOption) {\n                _depositLong(Actions._parseDepositArgs(action));\n            } else if (actionType == Actions.ActionType.WithdrawLongOption) {\n                _withdrawLong(Actions._parseWithdrawArgs(action));\n            } else if (actionType == Actions.ActionType.DepositCollateral) {\n                _depositCollateral(Actions._parseDepositArgs(action));\n            } else if (actionType == Actions.ActionType.WithdrawCollateral) {\n                _withdrawCollateral(Actions._parseWithdrawArgs(action));\n            } else if (actionType == Actions.ActionType.MintShortOption) {\n                _mintOtoken(Actions._parseMintArgs(action));\n            } else if (actionType == Actions.ActionType.BurnShortOption) {\n                _burnOtoken(Actions._parseBurnArgs(action));\n            } else if (actionType == Actions.ActionType.Redeem) {\n                _redeem(Actions._parseRedeemArgs(action));\n            } else if (actionType == Actions.ActionType.SettleVault) {\n                _settleVault(Actions._parseSettleVaultArgs(action));\n            } else if (actionType == Actions.ActionType.Liquidate) {\n                _liquidate(Actions._parseLiquidateArgs(action));\n            } else if (actionType == Actions.ActionType.Call) {\n                _call(Actions._parseCallArgs(action));\n            }\n        }\n\n        return (vaultUpdated, vaultOwner, vaultId);\n    }\n\n    /**\n     * @notice verify the vault final state after executing all actions\n     * @param _owner account owner address\n     * @param _vaultId vault id of the final vault\n     */\n    function _verifyFinalState(address _owner, uint256 _vaultId) internal view {\n        (MarginVault.Vault memory vault, uint256 typeVault, ) = getVaultWithDetails(_owner, _vaultId);\n        (, bool isValidVault) = calculator.getExcessCollateral(vault, typeVault);\n\n        require(isValidVault, \"C14\");\n    }\n\n    /**\n     * @notice open a new vault inside an account\n     * @dev only the account owner or operator can open a vault, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args OpenVaultArgs structure\n     */\n    function _openVault(Actions.OpenVaultArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        uint256 vaultId = accountVaultCounter[_args.owner].add(1);\n\n        require(_args.vaultId == vaultId, \"C15\");\n\n        // store new vault\n        accountVaultCounter[_args.owner] = vaultId;\n        vaultType[_args.owner][vaultId] = _args.vaultType;\n\n        emit VaultOpened(_args.owner, vaultId, _args.vaultType);\n    }\n\n    /**\n     * @notice deposit a long oToken into a vault\n     * @dev only the account owner or operator can deposit a long oToken, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args DepositArgs structure\n     */\n    function _depositLong(Actions.DepositArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"C35\");\n        // only allow vault owner or vault operator to deposit long otoken\n        require((_args.from == msg.sender) || (_args.from == _args.owner), \"C16\");\n\n        require(whitelist.isWhitelistedOtoken(_args.asset), \"C17\");\n\n        OtokenInterface otoken = OtokenInterface(_args.asset);\n\n        require(now < otoken.expiryTimestamp(), \"C18\");\n\n        vaults[_args.owner][_args.vaultId].addLong(_args.asset, _args.amount, _args.index);\n\n        pool.transferToPool(_args.asset, _args.from, _args.amount);\n\n        emit LongOtokenDeposited(_args.asset, _args.owner, _args.from, _args.vaultId, _args.amount);\n    }\n\n    /**\n     * @notice withdraw a long oToken from a vault\n     * @dev only the account owner or operator can withdraw a long oToken, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args WithdrawArgs structure\n     */\n    function _withdrawLong(Actions.WithdrawArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"C35\");\n\n        OtokenInterface otoken = OtokenInterface(_args.asset);\n\n        require(now < otoken.expiryTimestamp(), \"C19\");\n\n        vaults[_args.owner][_args.vaultId].removeLong(_args.asset, _args.amount, _args.index);\n\n        pool.transferToUser(_args.asset, _args.to, _args.amount);\n\n        emit LongOtokenWithdrawed(_args.asset, _args.owner, _args.to, _args.vaultId, _args.amount);\n    }\n\n    /**\n     * @notice deposit a collateral asset into a vault\n     * @dev only the account owner or operator can deposit collateral, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args DepositArgs structure\n     */\n    function _depositCollateral(Actions.DepositArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"C35\");\n        // only allow vault owner or vault operator to deposit collateral\n        require((_args.from == msg.sender) || (_args.from == _args.owner), \"C20\");\n\n        require(whitelist.isWhitelistedCollateral(_args.asset), \"C21\");\n\n        (, uint256 typeVault, ) = getVaultWithDetails(_args.owner, _args.vaultId);\n\n        if (typeVault == 1) {\n            nakedPoolBalance[_args.asset] = nakedPoolBalance[_args.asset].add(_args.amount);\n\n            require(nakedPoolBalance[_args.asset] <= nakedCap[_args.asset], \"C37\");\n        }\n\n        vaults[_args.owner][_args.vaultId].addCollateral(_args.asset, _args.amount, _args.index);\n\n        pool.transferToPool(_args.asset, _args.from, _args.amount);\n\n        emit CollateralAssetDeposited(_args.asset, _args.owner, _args.from, _args.vaultId, _args.amount);\n    }\n\n    /**\n     * @notice withdraw a collateral asset from a vault\n     * @dev only the account owner or operator can withdraw collateral, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args WithdrawArgs structure\n     */\n    function _withdrawCollateral(Actions.WithdrawArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"C35\");\n\n        (MarginVault.Vault memory vault, uint256 typeVault, ) = getVaultWithDetails(_args.owner, _args.vaultId);\n\n        if (_isNotEmpty(vault.shortOtokens)) {\n            OtokenInterface otoken = OtokenInterface(vault.shortOtokens[0]);\n\n            require(now < otoken.expiryTimestamp(), \"C22\");\n        }\n\n        if (typeVault == 1) {\n            nakedPoolBalance[_args.asset] = nakedPoolBalance[_args.asset].sub(_args.amount);\n        }\n\n        vaults[_args.owner][_args.vaultId].removeCollateral(_args.asset, _args.amount, _args.index);\n\n        pool.transferToUser(_args.asset, _args.to, _args.amount);\n\n        emit CollateralAssetWithdrawed(_args.asset, _args.owner, _args.to, _args.vaultId, _args.amount);\n    }\n\n    /**\n     * @notice mint short oTokens from a vault which creates an obligation that is recorded in the vault\n     * @dev only the account owner or operator can mint an oToken, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args MintArgs structure\n     */\n    function _mintOtoken(Actions.MintArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"C35\");\n        require(whitelist.isWhitelistedOtoken(_args.otoken), \"C23\");\n\n        OtokenInterface otoken = OtokenInterface(_args.otoken);\n\n        require(now < otoken.expiryTimestamp(), \"C24\");\n\n        vaults[_args.owner][_args.vaultId].addShort(_args.otoken, _args.amount, _args.index);\n\n        otoken.mintOtoken(_args.to, _args.amount);\n\n        emit ShortOtokenMinted(_args.otoken, _args.owner, _args.to, _args.vaultId, _args.amount);\n    }\n\n    /**\n     * @notice burn oTokens to reduce or remove the minted oToken obligation recorded in a vault\n     * @dev only the account owner or operator can burn an oToken, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args MintArgs structure\n     */\n    function _burnOtoken(Actions.BurnArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        // check that vault id is valid for this vault owner\n        require(_checkVaultId(_args.owner, _args.vaultId), \"C35\");\n        // only allow vault owner or vault operator to burn otoken\n        require((_args.from == msg.sender) || (_args.from == _args.owner), \"C25\");\n\n        OtokenInterface otoken = OtokenInterface(_args.otoken);\n\n        // do not allow burning expired otoken\n        require(now < otoken.expiryTimestamp(), \"C26\");\n\n        // remove otoken from vault\n        vaults[_args.owner][_args.vaultId].removeShort(_args.otoken, _args.amount, _args.index);\n\n        // burn otoken\n        otoken.burnOtoken(_args.from, _args.amount);\n\n        emit ShortOtokenBurned(_args.otoken, _args.owner, _args.from, _args.vaultId, _args.amount);\n    }\n\n    /**\n     * @notice redeem an oToken after expiry, receiving the payout of the oToken in the collateral asset\n     * @dev cannot be called when system is fullyPaused\n     * @param _args RedeemArgs structure\n     */\n    function _redeem(Actions.RedeemArgs memory _args) internal {\n        OtokenInterface otoken = OtokenInterface(_args.otoken);\n\n        // check that otoken to redeem is whitelisted\n        require(whitelist.isWhitelistedOtoken(_args.otoken), \"C27\");\n\n        (address collateral, address underlying, address strike, uint256 expiry) = _getOtokenDetails(address(otoken));\n\n        // only allow redeeming expired otoken\n        require(now >= expiry, \"C28\");\n\n        require(_canSettleAssets(underlying, strike, collateral, expiry), \"C29\");\n\n        uint256 payout = getPayout(_args.otoken, _args.amount);\n\n        otoken.burnOtoken(msg.sender, _args.amount);\n\n        pool.transferToUser(collateral, _args.receiver, payout);\n\n        emit Redeem(_args.otoken, msg.sender, _args.receiver, collateral, _args.amount, payout);\n    }\n\n    /**\n     * @notice settle a vault after expiry, removing the net proceeds/collateral after both long and short oToken payouts have settled\n     * @dev deletes a vault of vaultId after net proceeds/collateral is removed, cannot be called when system is fullyPaused\n     * @param _args SettleVaultArgs structure\n     */\n    function _settleVault(Actions.SettleVaultArgs memory _args) internal onlyAuthorized(msg.sender, _args.owner) {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"C35\");\n\n        (MarginVault.Vault memory vault, uint256 typeVault, ) = getVaultWithDetails(_args.owner, _args.vaultId);\n\n        OtokenInterface otoken;\n\n        // new scope to avoid stack too deep error\n        // check if there is short or long otoken in vault\n        // do not allow settling vault that have no short or long otoken\n        // if there is a long otoken, burn it\n        // store otoken address outside of this scope\n        {\n            bool hasShort = _isNotEmpty(vault.shortOtokens);\n            bool hasLong = _isNotEmpty(vault.longOtokens);\n\n            require(hasShort || hasLong, \"C30\");\n\n            otoken = hasShort ? OtokenInterface(vault.shortOtokens[0]) : OtokenInterface(vault.longOtokens[0]);\n\n            if (hasLong) {\n                OtokenInterface longOtoken = OtokenInterface(vault.longOtokens[0]);\n\n                longOtoken.burnOtoken(address(pool), vault.longAmounts[0]);\n            }\n        }\n\n        (address collateral, address underlying, address strike, uint256 expiry) = _getOtokenDetails(address(otoken));\n\n        // do not allow settling vault with un-expired otoken\n        require(now >= expiry, \"C31\");\n        require(_canSettleAssets(underlying, strike, collateral, expiry), \"C29\");\n\n        (uint256 payout, bool isValidVault) = calculator.getExcessCollateral(vault, typeVault);\n\n        // require that vault is valid (has excess collateral) before settling\n        // to avoid allowing settling undercollateralized naked margin vault\n        require(isValidVault, \"C32\");\n\n        delete vaults[_args.owner][_args.vaultId];\n\n        if (typeVault == 1) {\n            nakedPoolBalance[collateral] = nakedPoolBalance[collateral].sub(payout);\n        }\n\n        pool.transferToUser(collateral, _args.to, payout);\n\n        uint256 vaultId = _args.vaultId;\n        address payoutRecipient = _args.to;\n\n        emit VaultSettled(_args.owner, address(otoken), payoutRecipient, payout, vaultId, typeVault);\n    }\n\n    /**\n     * @notice liquidate naked margin vault\n     * @dev can liquidate different vaults id in the same operate() call\n     * @param _args liquidation action arguments struct\n     */\n    function _liquidate(Actions.LiquidateArgs memory _args) internal notPartiallyPaused {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"C35\");\n\n        // check if vault is undercollateralized\n        // the price is the amount of collateral asset to pay per 1 repaid debt(otoken)\n        // collateralDust is the minimum amount of collateral that can be left in the vault when a partial liquidation occurs\n        (MarginVault.Vault memory vault, bool isUnderCollat, uint256 price, uint256 collateralDust) = _isLiquidatable(\n            _args.owner,\n            _args.vaultId,\n            _args.roundId\n        );\n\n        require(isUnderCollat, \"C33\");\n\n        // amount of collateral to offer to liquidator\n        uint256 collateralToSell = _args.amount.mul(price).div(1e8);\n\n        // if vault is partially liquidated (amount of short otoken is still greater than zero)\n        // make sure remaining collateral amount is greater than dust amount\n        if (vault.shortAmounts[0].sub(_args.amount) > 0) {\n            require(vault.collateralAmounts[0].sub(collateralToSell) >= collateralDust, \"C34\");\n        }\n\n        // burn short otoken from liquidator address, index of short otoken hardcoded at 0\n        // this should always work, if vault have no short otoken, it will not reach this step\n        OtokenInterface(vault.shortOtokens[0]).burnOtoken(msg.sender, _args.amount);\n\n        // decrease amount of collateral in liquidated vault, index of collateral to decrease is hardcoded at 0\n        vaults[_args.owner][_args.vaultId].removeCollateral(vault.collateralAssets[0], collateralToSell, 0);\n\n        // decrease amount of short otoken in liquidated vault, index of short otoken to decrease is hardcoded at 0\n        vaults[_args.owner][_args.vaultId].removeShort(vault.shortOtokens[0], _args.amount, 0);\n\n        // decrease internal naked margin collateral amount\n        nakedPoolBalance[vault.collateralAssets[0]] = nakedPoolBalance[vault.collateralAssets[0]].sub(collateralToSell);\n\n        pool.transferToUser(vault.collateralAssets[0], _args.receiver, collateralToSell);\n\n        emit VaultLiquidated(\n            msg.sender,\n            _args.receiver,\n            _args.owner,\n            price,\n            _args.roundId,\n            collateralToSell,\n            _args.amount,\n            _args.vaultId\n        );\n    }\n\n    /**\n     * @notice execute arbitrary calls\n     * @dev cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args Call action\n     */\n    function _call(Actions.CallArgs memory _args) internal notPartiallyPaused onlyWhitelistedCallee(_args.callee) {\n        CalleeInterface(_args.callee).callFunction(msg.sender, _args.data);\n\n        emit CallExecuted(msg.sender, _args.callee, _args.data);\n    }\n\n    /**\n     * @notice check if a vault id is valid for a given account owner address\n     * @param _accountOwner account owner address\n     * @param _vaultId vault id to check\n     * @return True if the _vaultId is valid, False if not\n     */\n    function _checkVaultId(address _accountOwner, uint256 _vaultId) internal view returns (bool) {\n        return ((_vaultId > 0) && (_vaultId <= accountVaultCounter[_accountOwner]));\n    }\n\n    function _isNotEmpty(address[] memory _array) internal pure returns (bool) {\n        return (_array.length > 0) && (_array[0] != address(0));\n    }\n\n    /**\n     * @notice return if a callee address is whitelisted or not\n     * @param _callee callee address\n     * @return True if callee address is whitelisted, False if not\n     */\n    function _isCalleeWhitelisted(address _callee) internal view returns (bool) {\n        return whitelist.isWhitelistedCallee(_callee);\n    }\n\n    /**\n     * @notice check if a vault is liquidatable in a specific round id\n     * @param _owner vault owner address\n     * @param _vaultId vault id to check\n     * @param _roundId chainlink round id to check vault status at\n     * @return vault struct, isLiquidatable, true if vault is undercollateralized, the price of 1 repaid otoken and the otoken collateral dust amount\n     */\n    function _isLiquidatable(\n        address _owner,\n        uint256 _vaultId,\n        uint256 _roundId\n    )\n        internal\n        view\n        returns (\n            MarginVault.Vault memory,\n            bool,\n            uint256,\n            uint256\n        )\n    {\n        (MarginVault.Vault memory vault, uint256 typeVault, uint256 latestUpdateTimestamp) = getVaultWithDetails(\n            _owner,\n            _vaultId\n        );\n        (bool isUnderCollat, uint256 price, uint256 collateralDust) = calculator.isLiquidatable(\n            vault,\n            typeVault,\n            latestUpdateTimestamp,\n            _roundId\n        );\n\n        return (vault, isUnderCollat, price, collateralDust);\n    }\n\n    /**\n     * @dev get otoken detail, from both otoken versions\n     */\n    function _getOtokenDetails(address _otoken)\n        internal\n        view\n        returns (\n            address,\n            address,\n            address,\n            uint256\n        )\n    {\n        OtokenInterface otoken = OtokenInterface(_otoken);\n        try otoken.getOtokenDetails() returns (\n            address collateral,\n            address underlying,\n            address strike,\n            uint256,\n            uint256 expiry,\n            bool\n        ) {\n            return (collateral, underlying, strike, expiry);\n        } catch {\n            return (otoken.collateralAsset(), otoken.underlyingAsset(), otoken.strikeAsset(), otoken.expiryTimestamp());\n        }\n    }\n\n    /**\n     * @dev return if an expired oToken is ready to be settled, only true when price for underlying,\n     * strike and collateral assets at this specific expiry is available in our Oracle module\n     * @return True if the oToken has expired AND all oracle prices at the expiry timestamp have been finalized, False if not\n     */\n    function _canSettleAssets(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        uint256 _expiry\n    ) internal view returns (bool) {\n        return\n            oracle.isDisputePeriodOver(_underlying, _expiry) &&\n            oracle.isDisputePeriodOver(_strike, _expiry) &&\n            oracle.isDisputePeriodOver(_collateral, _expiry);\n    }\n\n    /**\n     * @dev updates the internal configuration of the controller\n     */\n    function _refreshConfigInternal() internal {\n        whitelist = WhitelistInterface(addressbook.getWhitelist());\n        oracle = OracleInterface(addressbook.getOracle());\n        calculator = MarginCalculatorInterface(addressbook.getMarginCalculator());\n        pool = MarginPoolInterface(addressbook.getMarginPool());\n    }\n}\n"
    },
    "contracts/libs/MarginVault.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity =0.6.10;\n\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"../packages/oz/SafeMath.sol\";\n\n/**\n * MarginVault Error Codes\n * V1: invalid short otoken amount\n * V2: invalid short otoken index\n * V3: short otoken address mismatch\n * V4: invalid long otoken amount\n * V5: invalid long otoken index\n * V6: long otoken address mismatch\n * V7: invalid collateral amount\n * V8: invalid collateral token index\n * V9: collateral token address mismatch\n */\n\n/**\n * @title MarginVault\n * @author Opyn Team\n * @notice A library that provides the Controller with a Vault struct and the functions that manipulate vaults.\n * Vaults describe discrete position combinations of long options, short options, and collateral assets that a user can have.\n */\nlibrary MarginVault {\n    using SafeMath for uint256;\n\n    // vault is a struct of 6 arrays that describe a position a user has, a user can have multiple vaults.\n    struct Vault {\n        // addresses of oTokens a user has shorted (i.e. written) against this vault\n        address[] shortOtokens;\n        // addresses of oTokens a user has bought and deposited in this vault\n        // user can be long oTokens without opening a vault (e.g. by buying on a DEX)\n        // generally, long oTokens will be 'deposited' in vaults to act as collateral in order to write oTokens against (i.e. in spreads)\n        address[] longOtokens;\n        // addresses of other ERC-20s a user has deposited as collateral in this vault\n        address[] collateralAssets;\n        // quantity of oTokens minted/written for each oToken address in shortOtokens\n        uint256[] shortAmounts;\n        // quantity of oTokens owned and held in the vault for each oToken address in longOtokens\n        uint256[] longAmounts;\n        // quantity of ERC-20 deposited as collateral in the vault for each ERC-20 address in collateralAssets\n        uint256[] collateralAmounts;\n    }\n\n    /**\n     * @dev increase the short oToken balance in a vault when a new oToken is minted\n     * @param _vault vault to add or increase the short position in\n     * @param _shortOtoken address of the _shortOtoken being minted from the user's vault\n     * @param _amount number of _shortOtoken being minted from the user's vault\n     * @param _index index of _shortOtoken in the user's vault.shortOtokens array\n     */\n    function addShort(\n        Vault storage _vault,\n        address _shortOtoken,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        require(_amount > 0, \"V1\");\n\n        // valid indexes in any array are between 0 and array.length - 1.\n        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1\n        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {\n            _vault.shortOtokens.push(_shortOtoken);\n            _vault.shortAmounts.push(_amount);\n        } else {\n            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), \"V2\");\n            address existingShort = _vault.shortOtokens[_index];\n            require((existingShort == _shortOtoken) || (existingShort == address(0)), \"V3\");\n\n            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);\n            _vault.shortOtokens[_index] = _shortOtoken;\n        }\n    }\n\n    /**\n     * @dev decrease the short oToken balance in a vault when an oToken is burned\n     * @param _vault vault to decrease short position in\n     * @param _shortOtoken address of the _shortOtoken being reduced in the user's vault\n     * @param _amount number of _shortOtoken being reduced in the user's vault\n     * @param _index index of _shortOtoken in the user's vault.shortOtokens array\n     */\n    function removeShort(\n        Vault storage _vault,\n        address _shortOtoken,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        // check that the removed short oToken exists in the vault at the specified index\n        require(_index < _vault.shortOtokens.length, \"V2\");\n        require(_vault.shortOtokens[_index] == _shortOtoken, \"V3\");\n\n        uint256 newShortAmount = _vault.shortAmounts[_index].sub(_amount);\n\n        if (newShortAmount == 0) {\n            delete _vault.shortOtokens[_index];\n        }\n        _vault.shortAmounts[_index] = newShortAmount;\n    }\n\n    /**\n     * @dev increase the long oToken balance in a vault when an oToken is deposited\n     * @param _vault vault to add a long position to\n     * @param _longOtoken address of the _longOtoken being added to the user's vault\n     * @param _amount number of _longOtoken the protocol is adding to the user's vault\n     * @param _index index of _longOtoken in the user's vault.longOtokens array\n     */\n    function addLong(\n        Vault storage _vault,\n        address _longOtoken,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        require(_amount > 0, \"V4\");\n\n        // valid indexes in any array are between 0 and array.length - 1.\n        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1\n        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {\n            _vault.longOtokens.push(_longOtoken);\n            _vault.longAmounts.push(_amount);\n        } else {\n            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), \"V5\");\n            address existingLong = _vault.longOtokens[_index];\n            require((existingLong == _longOtoken) || (existingLong == address(0)), \"V6\");\n\n            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);\n            _vault.longOtokens[_index] = _longOtoken;\n        }\n    }\n\n    /**\n     * @dev decrease the long oToken balance in a vault when an oToken is withdrawn\n     * @param _vault vault to remove a long position from\n     * @param _longOtoken address of the _longOtoken being removed from the user's vault\n     * @param _amount number of _longOtoken the protocol is removing from the user's vault\n     * @param _index index of _longOtoken in the user's vault.longOtokens array\n     */\n    function removeLong(\n        Vault storage _vault,\n        address _longOtoken,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        // check that the removed long oToken exists in the vault at the specified index\n        require(_index < _vault.longOtokens.length, \"V5\");\n        require(_vault.longOtokens[_index] == _longOtoken, \"V6\");\n\n        uint256 newLongAmount = _vault.longAmounts[_index].sub(_amount);\n\n        if (newLongAmount == 0) {\n            delete _vault.longOtokens[_index];\n        }\n        _vault.longAmounts[_index] = newLongAmount;\n    }\n\n    /**\n     * @dev increase the collateral balance in a vault\n     * @param _vault vault to add collateral to\n     * @param _collateralAsset address of the _collateralAsset being added to the user's vault\n     * @param _amount number of _collateralAsset being added to the user's vault\n     * @param _index index of _collateralAsset in the user's vault.collateralAssets array\n     */\n    function addCollateral(\n        Vault storage _vault,\n        address _collateralAsset,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        require(_amount > 0, \"V7\");\n\n        // valid indexes in any array are between 0 and array.length - 1.\n        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1\n        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {\n            _vault.collateralAssets.push(_collateralAsset);\n            _vault.collateralAmounts.push(_amount);\n        } else {\n            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), \"V8\");\n            address existingCollateral = _vault.collateralAssets[_index];\n            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), \"V9\");\n\n            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);\n            _vault.collateralAssets[_index] = _collateralAsset;\n        }\n    }\n\n    /**\n     * @dev decrease the collateral balance in a vault\n     * @param _vault vault to remove collateral from\n     * @param _collateralAsset address of the _collateralAsset being removed from the user's vault\n     * @param _amount number of _collateralAsset being removed from the user's vault\n     * @param _index index of _collateralAsset in the user's vault.collateralAssets array\n     */\n    function removeCollateral(\n        Vault storage _vault,\n        address _collateralAsset,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        // check that the removed collateral exists in the vault at the specified index\n        require(_index < _vault.collateralAssets.length, \"V8\");\n        require(_vault.collateralAssets[_index] == _collateralAsset, \"V9\");\n\n        uint256 newCollateralAmount = _vault.collateralAmounts[_index].sub(_amount);\n\n        if (newCollateralAmount == 0) {\n            delete _vault.collateralAssets[_index];\n        }\n        _vault.collateralAmounts[_index] = newCollateralAmount;\n    }\n}\n"
    },
    "contracts/packages/oz/upgradeability/OwnableUpgradeSafe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts-upgradeable v3.0.0\n\npragma solidity ^0.6.0;\n\nimport \"./GSN/ContextUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract OwnableUpgradeSafe is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n\n    function __Ownable_init(address _sender) internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained(_sender);\n    }\n\n    function __Ownable_init_unchained(address _sender) internal initializer {\n        _owner = _sender;\n        emit OwnershipTransferred(address(0), _sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/packages/oz/upgradeability/ReentrancyGuardUpgradeSafe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts-upgradeable v3.0.0\n\npragma solidity ^0.6.0;\n\nimport \"./Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuardUpgradeSafe is Initializable {\n    bool private _notEntered;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction's gas, it is best to keep them low in cases\n        // like this one, to increase the likelihood of the full refund coming\n        // into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/interfaces/OtokenInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\ninterface OtokenInterface {\n    function addressBook() external view returns (address);\n\n    function underlyingAsset() external view returns (address);\n\n    function strikeAsset() external view returns (address);\n\n    function collateralAsset() external view returns (address);\n\n    function strikePrice() external view returns (uint256);\n\n    function expiryTimestamp() external view returns (uint256);\n\n    function isPut() external view returns (bool);\n\n    function init(\n        address _addressBook,\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external;\n\n    function getOtokenDetails()\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            uint256,\n            uint256,\n            bool\n        );\n\n    function mintOtoken(address account, uint256 amount) external;\n\n    function burnOtoken(address account, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/MarginCalculatorInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\npragma experimental ABIEncoderV2;\n\nimport {MarginVault} from \"../libs/MarginVault.sol\";\n\ninterface MarginCalculatorInterface {\n    function addressBook() external view returns (address);\n\n    function getExpiredPayoutRate(address _otoken) external view returns (uint256);\n\n    function getExcessCollateral(MarginVault.Vault calldata _vault, uint256 _vaultType)\n        external\n        view\n        returns (uint256 netValue, bool isExcess);\n\n    function isLiquidatable(\n        MarginVault.Vault memory _vault,\n        uint256 _vaultType,\n        uint256 _vaultLatestUpdate,\n        uint256 _roundId\n    )\n        external\n        view\n        returns (\n            bool,\n            uint256,\n            uint256\n        );\n}\n"
    },
    "contracts/interfaces/WhitelistInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\ninterface WhitelistInterface {\n    /* View functions */\n\n    function addressBook() external view returns (address);\n\n    function isWhitelistedProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external view returns (bool);\n\n    function isWhitelistedCollateral(address _collateral) external view returns (bool);\n\n    function isWhitelistedOtoken(address _otoken) external view returns (bool);\n\n    function isWhitelistedCallee(address _callee) external view returns (bool);\n\n    /* Admin / factory only functions */\n    function whitelistProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external;\n\n    function blacklistProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external;\n\n    function whitelistCollateral(address _collateral) external;\n\n    function blacklistCollateral(address _collateral) external;\n\n    function whitelistOtoken(address _otoken) external;\n\n    function blacklistOtoken(address _otoken) external;\n\n    function whitelistCallee(address _callee) external;\n\n    function blacklistCallee(address _callee) external;\n}\n"
    },
    "contracts/interfaces/MarginPoolInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\ninterface MarginPoolInterface {\n    /* Getters */\n    function addressBook() external view returns (address);\n\n    function farmer() external view returns (address);\n\n    function getStoredBalance(address _asset) external view returns (uint256);\n\n    /* Admin-only functions */\n    function setFarmer(address _farmer) external;\n\n    function farm(\n        address _asset,\n        address _receiver,\n        uint256 _amount\n    ) external;\n\n    /* Controller-only functions */\n    function transferToPool(\n        address _asset,\n        address _user,\n        uint256 _amount\n    ) external;\n\n    function transferToUser(\n        address _asset,\n        address _user,\n        uint256 _amount\n    ) external;\n\n    function batchTransferToPool(\n        address[] calldata _asset,\n        address[] calldata _user,\n        uint256[] calldata _amount\n    ) external;\n\n    function batchTransferToUser(\n        address[] calldata _asset,\n        address[] calldata _user,\n        uint256[] calldata _amount\n    ) external;\n}\n"
    },
    "contracts/tests/CalleeAllowanceTester.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\npragma experimental ABIEncoderV2;\n\nimport {CalleeInterface} from \"../interfaces/CalleeInterface.sol\";\nimport {ERC20Interface} from \"../interfaces/ERC20Interface.sol\";\nimport {SafeERC20} from \"../packages/oz/SafeERC20.sol\";\n\n/**\n * @author Opyn Team\n * @title CalleeAllowanceTester\n * @notice contract test if we can successfully pull weth from the payable proxy\n */\ncontract CalleeAllowanceTester is CalleeInterface {\n    using SafeERC20 for ERC20Interface;\n    ERC20Interface public weth;\n\n    constructor(address _weth) public {\n        weth = ERC20Interface(_weth);\n    }\n\n    // tset pull token\n    function callFunction(address payable, bytes memory _data) external override {\n        (address from, uint256 amount) = abi.decode(_data, (address, uint256));\n\n        weth.safeTransferFrom(from, address(this), amount);\n    }\n}\n"
    },
    "contracts/mocks/MockController.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\n// import \"../packages/oz/upgradeability/VersionedInitializable.sol\";\nimport \"../interfaces/OtokenInterface.sol\";\nimport \"../interfaces/CalleeInterface.sol\";\nimport \"../interfaces/ERC20Interface.sol\";\n\n/**\n * @author Opyn Team\n * @notice Upgradeable Controller that can mock minting and burning calls from controller.\n */\ncontract MockController {\n    /// @notice addressbook address\n    address public addressBook;\n    address public owner;\n\n    /**\n     * @dev this function is invoked by the proxy contract when this contract is added to the\n     * AddressBook.\n     * @param _addressBook the address of the AddressBook\n     **/\n    function initialize(address _addressBook, address _owner) external {\n        addressBook = _addressBook;\n        owner = _owner;\n    }\n\n    /**\n     * @dev this function is used to test if controller can mint otokens\n     */\n    function testMintOtoken(\n        address _otoken,\n        address _account,\n        uint256 _amount\n    ) external {\n        OtokenInterface(_otoken).mintOtoken(_account, _amount);\n    }\n\n    /**\n     * @dev this function is used to test if controller can burn otokens\n     */\n    function testBurnOtoken(\n        address _otoken,\n        address _account,\n        uint256 _amount\n    ) external {\n        OtokenInterface(_otoken).burnOtoken(_account, _amount);\n    }\n\n    /**\n     * @dev this function is used to test if controller can be the only msg.sender to the 0xcallee\n     */\n    function test0xCallee(address _callee, bytes memory _data) external {\n        CalleeInterface(_callee).callFunction(msg.sender, _data);\n    }\n}\n"
    },
    "contracts/core/OtokenFactory.sol": {
      "content": "pragma solidity =0.6.10;\n\nimport {OtokenSpawner} from \"./OtokenSpawner.sol\";\nimport {SafeMath} from \"../packages/oz/SafeMath.sol\";\nimport {AddressBookInterface} from \"../interfaces/AddressBookInterface.sol\";\nimport {OtokenInterface} from \"../interfaces/OtokenInterface.sol\";\nimport {WhitelistInterface} from \"../interfaces/WhitelistInterface.sol\";\n\n/**\n * SPDX-License-Identifier: UNLICENSED\n * @title A factory to create Opyn oTokens\n * @author Opyn Team\n * @notice Create new oTokens and keep track of all created tokens\n * @dev Calculate contract address before each creation with CREATE2\n * and deploy eip-1167 minimal proxies for oToken logic contract\n */\ncontract OtokenFactory is OtokenSpawner {\n    using SafeMath for uint256;\n    /// @notice Opyn AddressBook contract that records the address of the Whitelist module and the Otoken impl address. */\n    address public addressBook;\n\n    /// @notice array of all created otokens */\n    address[] public otokens;\n\n    /// @dev mapping from parameters hash to its deployed address\n    mapping(bytes32 => address) private idToAddress;\n\n    /// @dev max expiry that BokkyPooBahsDateTimeLibrary can handle. (2345/12/31)\n    uint256 private constant MAX_EXPIRY = 11865398400;\n\n    constructor(address _addressBook) public {\n        addressBook = _addressBook;\n    }\n\n    /// @notice emitted when the factory creates a new Option\n    event OtokenCreated(\n        address tokenAddress,\n        address creator,\n        address indexed underlying,\n        address indexed strike,\n        address indexed collateral,\n        uint256 strikePrice,\n        uint256 expiry,\n        bool isPut\n    );\n\n    /**\n     * @notice create new oTokens\n     * @dev deploy an eip-1167 minimal proxy with CREATE2 and register it to the whitelist module\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return newOtoken address of the newly created option\n     */\n    function createOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external returns (address) {\n        require(_expiry > now, \"OtokenFactory: Can't create expired option\");\n        require(_expiry < MAX_EXPIRY, \"OtokenFactory: Can't create option with expiry > 2345/12/31\");\n        // 8 hours = 3600 * 8 = 28800 seconds\n        require(_expiry.sub(28800).mod(86400) == 0, \"OtokenFactory: Option has to expire 08:00 UTC\");\n        bytes32 id = _getOptionId(_underlyingAsset, _strikeAsset, _collateralAsset, _strikePrice, _expiry, _isPut);\n        require(idToAddress[id] == address(0), \"OtokenFactory: Option already created\");\n\n        address whitelist = AddressBookInterface(addressBook).getWhitelist();\n        require(\n            WhitelistInterface(whitelist).isWhitelistedProduct(\n                _underlyingAsset,\n                _strikeAsset,\n                _collateralAsset,\n                _isPut\n            ),\n            \"OtokenFactory: Unsupported Product\"\n        );\n\n        require(!_isPut || _strikePrice > 0, \"OtokenFactory: Can't create a $0 strike put option\");\n\n        address otokenImpl = AddressBookInterface(addressBook).getOtokenImpl();\n\n        bytes memory initializationCalldata = abi.encodeWithSelector(\n            OtokenInterface(otokenImpl).init.selector,\n            addressBook,\n            _underlyingAsset,\n            _strikeAsset,\n            _collateralAsset,\n            _strikePrice,\n            _expiry,\n            _isPut\n        );\n\n        address newOtoken = _spawn(otokenImpl, initializationCalldata);\n\n        idToAddress[id] = newOtoken;\n        otokens.push(newOtoken);\n        WhitelistInterface(whitelist).whitelistOtoken(newOtoken);\n\n        emit OtokenCreated(\n            newOtoken,\n            msg.sender,\n            _underlyingAsset,\n            _strikeAsset,\n            _collateralAsset,\n            _strikePrice,\n            _expiry,\n            _isPut\n        );\n\n        return newOtoken;\n    }\n\n    /**\n     * @notice get the total oTokens created by the factory\n     * @return length of the oTokens array\n     */\n    function getOtokensLength() external view returns (uint256) {\n        return otokens.length;\n    }\n\n    /**\n     * @notice get the oToken address for an already created oToken, if no oToken has been created with these parameters, it will return address(0)\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return the address of target otoken.\n     */\n    function getOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external view returns (address) {\n        bytes32 id = _getOptionId(_underlyingAsset, _strikeAsset, _collateralAsset, _strikePrice, _expiry, _isPut);\n        return idToAddress[id];\n    }\n\n    /**\n     * @notice get the address at which a new oToken with these parameters would be deployed\n     * @dev return the exact address that will be deployed at with _computeAddress\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return targetAddress the address this oToken would be deployed at\n     */\n    function getTargetOtokenAddress(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external view returns (address) {\n        address otokenImpl = AddressBookInterface(addressBook).getOtokenImpl();\n\n        bytes memory initializationCalldata = abi.encodeWithSelector(\n            OtokenInterface(otokenImpl).init.selector,\n            addressBook,\n            _underlyingAsset,\n            _strikeAsset,\n            _collateralAsset,\n            _strikePrice,\n            _expiry,\n            _isPut\n        );\n        return _computeAddress(otokenImpl, initializationCalldata);\n    }\n\n    /**\n     * @dev hash oToken parameters and return a unique option id\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return id the unique id of an oToken\n     */\n    function _getOptionId(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(_underlyingAsset, _strikeAsset, _collateralAsset, _strikePrice, _expiry, _isPut)\n            );\n    }\n}\n"
    },
    "contracts/core/OtokenSpawner.sol": {
      "content": "/* SPDX-License-Identifier: UNLICENSED */\n\npragma solidity =0.6.10;\n\nimport {Spawn} from \"../packages/Spawn.sol\";\nimport {Create2} from \"../packages/oz/Create2.sol\";\n\n/**\n * @title OtokenSpawner\n * @author Opyn Team\n * @notice This contract spawns and initializes eip-1167 minimal proxies that\n * point to existing logic contracts.\n * @notice This contract was modified from Spawner.sol\n * https://github.com/0age/Spawner/blob/master/contracts/Spawner.sol to fit into OtokenFactory\n */\ncontract OtokenSpawner {\n    // fixed salt value because we will only deploy an oToken with the same init value once\n    bytes32 private constant SALT = bytes32(0);\n\n    /**\n     * @notice internal function for spawning an eip-1167 minimal proxy using `CREATE2`\n     * @param logicContract address of the logic contract\n     * @param initializationCalldata calldata that will be supplied to the `DELEGATECALL`\n     * from the spawned contract to the logic contract during contract creation\n     * @return spawnedContract the address of the newly-spawned contract\n     */\n    function _spawn(address logicContract, bytes memory initializationCalldata) internal returns (address) {\n        // place the creation code and constructor args of the contract to spawn in memory\n        bytes memory initCode = abi.encodePacked(\n            type(Spawn).creationCode,\n            abi.encode(logicContract, initializationCalldata)\n        );\n\n        // spawn the contract using `CREATE2`\n        return Create2.deploy(0, SALT, initCode);\n    }\n\n    /**\n     * @notice internal view function for finding the address of the standard\n     * eip-1167 minimal proxy created using `CREATE2` with a given logic contract\n     * and initialization calldata payload\n     * @param logicContract address of the logic contract\n     * @param initializationCalldata calldata that will be supplied to the `DELEGATECALL`\n     * from the spawned contract to the logic contract during contract creation\n     * @return target address of the next spawned minimal proxy contract with the\n     * given parameters.\n     */\n    function _computeAddress(address logicContract, bytes memory initializationCalldata)\n        internal\n        view\n        returns (address target)\n    {\n        // place the creation code and constructor args of the contract to spawn in memory\n        bytes memory initCode = abi.encodePacked(\n            type(Spawn).creationCode,\n            abi.encode(logicContract, initializationCalldata)\n        );\n        // get target address using the constructed initialization code\n        bytes32 initCodeHash = keccak256(initCode);\n\n        target = Create2.computeAddress(SALT, initCodeHash);\n    }\n}\n"
    },
    "contracts/packages/Spawn.sol": {
      "content": "/* solhint-disable avoid-low-level-calls, indent, no-inline-assembly */\n/* This contract is copied from Spawner package: https://github.com/0age/Spawner */\npragma solidity =0.6.10;\n\n/**\n * @title Spawn\n * @author 0age\n * @notice This contract provides creation code that is used by Spawner in order\n * to initialize and deploy eip-1167 minimal proxies for a given logic contract.\n * SPDX-License-Identifier: MIT\n */\n// version: https://github.com/0age/Spawner/blob/1b342afda0c1ec47e6a2d65828a6ca50f0a442fe/contracts/Spawner.sol\ncontract Spawn {\n    constructor(address logicContract, bytes memory initializationCalldata) public payable {\n        // delegatecall into the logic contract to perform initialization.\n        (bool ok, ) = logicContract.delegatecall(initializationCalldata);\n        if (!ok) {\n            // pass along failure message from delegatecall and revert.\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // place eip-1167 runtime code in memory.\n        bytes memory runtimeCode = abi.encodePacked(\n            bytes10(0x363d3d373d3d3d363d73),\n            logicContract,\n            bytes15(0x5af43d82803e903d91602b57fd5bf3)\n        );\n\n        // return eip-1167 code to write it to spawned contract runtime.\n        assembly {\n            return(add(0x20, runtimeCode), 45) // eip-1167 runtime code, length\n        }\n    }\n}\n"
    },
    "contracts/packages/oz/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts v3.1.0\n/* solhint-disable */\n\npragma solidity =0.6.10;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address) {\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\n        return address(uint256(_data));\n    }\n}\n"
    },
    "contracts/pricers/WstethPricer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.6.10;\n\nimport {OracleInterface} from \"../interfaces/OracleInterface.sol\";\nimport {OpynPricerInterface} from \"../interfaces/OpynPricerInterface.sol\";\nimport {WSTETHInterface} from \"../interfaces/WSTETHInterface.sol\";\nimport {SafeMath} from \"../packages/oz/SafeMath.sol\";\n\n/**\n * Error Codes\n * W1: cannot deploy pricer, wstETH address cannot be 0\n * W2: cannot deploy pricer, underlying address cannot be 0\n * W3: cannot deploy pricer, oracle address cannot be 0\n * W4: cannot retrieve price, underlying price is 0\n * W5: cannot set expiry price in oracle, underlying price is 0 and has not been set\n * W6: cannot retrieve historical prices, getHistoricalPrice has been deprecated\n */\n\n/**\n * @title WstethPricer\n * @author Opyn Team\n * @notice A Pricer contract for a wstETH token\n */\ncontract WstethPricer is OpynPricerInterface {\n    using SafeMath for uint256;\n\n    /// @notice opyn oracle address\n    OracleInterface public oracle;\n\n    /// @notice wstETH token\n    WSTETHInterface public wstETH;\n\n    /// @notice underlying asset (WETH)\n    address public underlying;\n\n    /**\n     * @param _wstETH wstETH\n     * @param _underlying underlying asset for wstETH\n     * @param _oracle Opyn Oracle contract address\n     */\n    constructor(\n        address _wstETH,\n        address _underlying,\n        address _oracle\n    ) public {\n        require(_wstETH != address(0), \"W1\");\n        require(_underlying != address(0), \"W2\");\n        require(_oracle != address(0), \"W3\");\n\n        wstETH = WSTETHInterface(_wstETH);\n        oracle = OracleInterface(_oracle);\n        underlying = _underlying;\n    }\n\n    /**\n     * @notice get the live price for the asset\n     * @dev overrides the getPrice function in OpynPricerInterface\n     * @return price of 1 wstETH in USD, scaled by 1e8\n     */\n    function getPrice() external view override returns (uint256) {\n        uint256 underlyingPrice = oracle.getPrice(underlying);\n        require(underlyingPrice > 0, \"W4\");\n        return _underlyingPriceToWstethPrice(underlyingPrice);\n    }\n\n    /**\n     * @notice set the expiry price in the oracle\n     * @dev requires that the underlying price has been set before setting a wstETH price\n     * @param _expiryTimestamp expiry to set a price for\n     */\n    function setExpiryPriceInOracle(uint256 _expiryTimestamp) external {\n        (uint256 underlyingPriceExpiry, ) = oracle.getExpiryPrice(underlying, _expiryTimestamp);\n        require(underlyingPriceExpiry > 0, \"W5\");\n        uint256 wstEthPrice = _underlyingPriceToWstethPrice(underlyingPriceExpiry);\n        oracle.setExpiryPrice(address(wstETH), _expiryTimestamp, wstEthPrice);\n    }\n\n    /**\n     * @dev convert underlying price to wstETH price with the wstETH to stETH exchange rate (1 stETH ≈ 1 ETH)\n     * @param _underlyingPrice price of 1 underlying token (ie 1e18 WETH) in USD, scaled by 1e8\n     * @return price of 1 wstETH in USD, scaled by 1e8\n     */\n    function _underlyingPriceToWstethPrice(uint256 _underlyingPrice) private view returns (uint256) {\n        uint256 stEthPerWsteth = wstETH.stEthPerToken();\n\n        return stEthPerWsteth.mul(_underlyingPrice).div(1e18);\n    }\n\n    function getHistoricalPrice(uint80) external view override returns (uint256, uint256) {\n        revert(\"W6\");\n    }\n}\n"
    },
    "contracts/interfaces/WSTETHInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.6.10;\n\ninterface WSTETHInterface {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function stEthPerToken() external view returns (uint256);\n}\n"
    },
    "contracts/pricers/ChainlinkPricer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\nimport {AggregatorInterface} from \"../interfaces/AggregatorInterface.sol\";\nimport {OracleInterface} from \"../interfaces/OracleInterface.sol\";\nimport {OpynPricerInterface} from \"../interfaces/OpynPricerInterface.sol\";\nimport {SafeMath} from \"../packages/oz/SafeMath.sol\";\n\n/**\n * @notice A Pricer contract for one asset as reported by Chainlink\n */\ncontract ChainLinkPricer is OpynPricerInterface {\n    using SafeMath for uint256;\n\n    /// @dev base decimals\n    uint256 internal constant BASE = 8;\n\n    /// @notice chainlink response decimals\n    uint256 public aggregatorDecimals;\n\n    /// @notice the opyn oracle address\n    OracleInterface public oracle;\n    /// @notice the aggregator for an asset\n    AggregatorInterface public aggregator;\n\n    /// @notice asset that this pricer will a get price for\n    address public asset;\n    /// @notice bot address that is allowed to call setExpiryPriceInOracle\n    address public bot;\n\n    /**\n     * @param _bot priveleged address that can call setExpiryPriceInOracle\n     * @param _asset asset that this pricer will get a price for\n     * @param _aggregator Chainlink aggregator contract for the asset\n     * @param _oracle Opyn Oracle address\n     */\n    constructor(\n        address _bot,\n        address _asset,\n        address _aggregator,\n        address _oracle\n    ) public {\n        require(_bot != address(0), \"ChainLinkPricer: Cannot set 0 address as bot\");\n        require(_oracle != address(0), \"ChainLinkPricer: Cannot set 0 address as oracle\");\n        require(_aggregator != address(0), \"ChainLinkPricer: Cannot set 0 address as aggregator\");\n\n        bot = _bot;\n        oracle = OracleInterface(_oracle);\n        aggregator = AggregatorInterface(_aggregator);\n        asset = _asset;\n\n        aggregatorDecimals = uint256(aggregator.decimals());\n    }\n\n    /**\n     * @notice set the expiry price in the oracle, can only be called by Bot address\n     * @dev a roundId must be provided to confirm price validity, which is the first Chainlink price provided after the expiryTimestamp\n     * @param _expiryTimestamp expiry to set a price for\n     * @param _roundId the first roundId after expiryTimestamp\n     */\n    function setExpiryPriceInOracle(uint256 _expiryTimestamp, uint80 _roundId) external {\n        (, int256 price, , uint256 roundTimestamp, ) = aggregator.getRoundData(_roundId);\n\n        require(_expiryTimestamp <= roundTimestamp, \"ChainLinkPricer: roundId not first after expiry\");\n        require(price >= 0, \"ChainLinkPricer: invalid price\");\n\n        if (msg.sender != bot) {\n            bool isCorrectRoundId;\n            uint80 previousRoundId = uint80(uint256(_roundId).sub(1));\n\n            while (!isCorrectRoundId) {\n                (, , , uint256 previousRoundTimestamp, ) = aggregator.getRoundData(previousRoundId);\n\n                if (previousRoundTimestamp == 0) {\n                    require(previousRoundId > 0, \"ChainLinkPricer: Invalid previousRoundId\");\n                    previousRoundId = previousRoundId - 1;\n                } else if (previousRoundTimestamp > _expiryTimestamp) {\n                    revert(\"ChainLinkPricer: previousRoundId not last before expiry\");\n                } else {\n                    isCorrectRoundId = true;\n                }\n            }\n        }\n\n        oracle.setExpiryPrice(asset, _expiryTimestamp, uint256(price));\n    }\n\n    /**\n     * @notice get the live price for the asset\n     * @dev overides the getPrice function in OpynPricerInterface\n     * @return price of the asset in USD, scaled by 1e8\n     */\n    function getPrice() external view override returns (uint256) {\n        (, int256 answer, , , ) = aggregator.latestRoundData();\n        require(answer > 0, \"ChainLinkPricer: price is lower than 0\");\n        // chainlink's answer is already 1e8\n        return _scaleToBase(uint256(answer));\n    }\n\n    /**\n     * @notice get historical chainlink price\n     * @param _roundId chainlink round id\n     * @return round price and timestamp\n     */\n    function getHistoricalPrice(uint80 _roundId) external view override returns (uint256, uint256) {\n        (, int256 price, , uint256 roundTimestamp, ) = aggregator.getRoundData(_roundId);\n        return (_scaleToBase(uint256(price)), roundTimestamp);\n    }\n\n    /**\n     * @notice scale aggregator response to base decimals (1e8)\n     * @param _price aggregator price\n     * @return price scaled to 1e8\n     */\n    function _scaleToBase(uint256 _price) internal view returns (uint256) {\n        if (aggregatorDecimals > BASE) {\n            uint256 exp = aggregatorDecimals.sub(BASE);\n            _price = _price.div(10**exp);\n        } else if (aggregatorDecimals < BASE) {\n            uint256 exp = BASE.sub(aggregatorDecimals);\n            _price = _price.mul(10**exp);\n        }\n\n        return _price;\n    }\n}\n"
    },
    "contracts/interfaces/AggregatorInterface.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\n/**\n * @dev Interface of the Chainlink aggregator\n */\ninterface AggregatorInterface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/mocks/MockOracle.sol": {
      "content": "pragma solidity =0.6.10;\n\nimport {SafeMath} from \"../packages/oz/SafeMath.sol\";\nimport {OpynPricerInterface} from \"../interfaces/OpynPricerInterface.sol\";\n\n/**\n * SPDX-License-Identifier: UNLICENSED\n * @dev The MockOracle contract let us easily manipulate the oracle state in testings.\n */\ncontract MockOracle {\n    struct Price {\n        uint256 price;\n        uint256 timestamp; // timestamp at which the price is pushed to this oracle\n    }\n\n    using SafeMath for uint256;\n\n    mapping(address => uint256) public realTimePrice;\n    mapping(address => mapping(uint256 => uint256)) public storedPrice;\n    mapping(address => uint256) internal stablePrice;\n    mapping(address => mapping(uint256 => bool)) public isFinalized;\n\n    mapping(address => uint256) internal pricerLockingPeriod;\n    mapping(address => uint256) internal pricerDisputePeriod;\n    mapping(address => address) internal assetPricer;\n\n    // asset => expiry => bool\n    mapping(address => mapping(uint256 => bool)) private _isDisputePeriodOver;\n    mapping(address => mapping(uint256 => bool)) private _isLockingPeriodOver;\n\n    // chainlink historic round data, asset => round => price/timestamp\n    mapping(address => mapping(uint80 => uint256)) private _roundPrice;\n    mapping(address => mapping(uint80 => uint256)) private _roundTimestamp;\n\n    function setRealTimePrice(address _asset, uint256 _price) external {\n        realTimePrice[_asset] = _price;\n    }\n\n    // get chainlink historic round data\n    function getChainlinkRoundData(address _asset, uint80 _roundId) external view returns (uint256, uint256) {\n        uint256 price = _roundPrice[_asset][_roundId];\n        uint256 timestamp = _roundTimestamp[_asset][_roundId];\n\n        return (price, timestamp);\n    }\n\n    function getPrice(address _asset) external view returns (uint256) {\n        uint256 price = stablePrice[_asset];\n\n        if (price == 0) {\n            price = realTimePrice[_asset];\n        }\n\n        return price;\n    }\n\n    // set chainlink historic data for specific round id\n    function setChainlinkRoundData(\n        address _asset,\n        uint80 _roundId,\n        uint256 _price,\n        uint256 _timestamp\n    ) external returns (uint256, uint256) {\n        _roundPrice[_asset][_roundId] = _price;\n        _roundTimestamp[_asset][_roundId] = _timestamp;\n    }\n\n    // set bunch of things at expiry in 1 function\n    function setExpiryPriceFinalizedAllPeiodOver(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _price,\n        bool _isFinalized\n    ) external {\n        storedPrice[_asset][_expiryTimestamp] = _price;\n        isFinalized[_asset][_expiryTimestamp] = _isFinalized;\n        _isDisputePeriodOver[_asset][_expiryTimestamp] = _isFinalized;\n        _isLockingPeriodOver[_asset][_expiryTimestamp] = _isFinalized;\n    }\n\n    // let the pricer set expiry price to oracle.\n    function setExpiryPrice(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _price\n    ) external {\n        storedPrice[_asset][_expiryTimestamp] = _price;\n    }\n\n    function setIsFinalized(\n        address _asset,\n        uint256 _expiryTimestamp,\n        bool _isFinalized\n    ) external {\n        isFinalized[_asset][_expiryTimestamp] = _isFinalized;\n    }\n\n    function getExpiryPrice(address _asset, uint256 _expiryTimestamp) external view returns (uint256, bool) {\n        uint256 price = stablePrice[_asset];\n        bool _isFinalized = true;\n\n        if (price == 0) {\n            price = storedPrice[_asset][_expiryTimestamp];\n            _isFinalized = isFinalized[_asset][_expiryTimestamp];\n        }\n\n        return (price, _isFinalized);\n    }\n\n    function getPricer(address _asset) external view returns (address) {\n        return assetPricer[_asset];\n    }\n\n    function getPricerLockingPeriod(address _pricer) external view returns (uint256) {\n        return pricerLockingPeriod[_pricer];\n    }\n\n    function getPricerDisputePeriod(address _pricer) external view returns (uint256) {\n        return pricerDisputePeriod[_pricer];\n    }\n\n    function isLockingPeriodOver(address _asset, uint256 _expiryTimestamp) public view returns (bool) {\n        return _isLockingPeriodOver[_asset][_expiryTimestamp];\n    }\n\n    function setIsLockingPeriodOver(\n        address _asset,\n        uint256 _expiryTimestamp,\n        bool _result\n    ) external {\n        _isLockingPeriodOver[_asset][_expiryTimestamp] = _result;\n    }\n\n    function isDisputePeriodOver(address _asset, uint256 _expiryTimestamp) external view returns (bool) {\n        return _isDisputePeriodOver[_asset][_expiryTimestamp];\n    }\n\n    function setIsDisputePeriodOver(\n        address _asset,\n        uint256 _expiryTimestamp,\n        bool _result\n    ) external {\n        _isDisputePeriodOver[_asset][_expiryTimestamp] = _result;\n    }\n\n    function setAssetPricer(address _asset, address _pricer) external {\n        assetPricer[_asset] = _pricer;\n    }\n\n    function setLockingPeriod(address _pricer, uint256 _lockingPeriod) external {\n        pricerLockingPeriod[_pricer] = _lockingPeriod;\n    }\n\n    function setDisputePeriod(address _pricer, uint256 _disputePeriod) external {\n        pricerDisputePeriod[_pricer] = _disputePeriod;\n    }\n\n    function setStablePrice(address _asset, uint256 _price) external {\n        stablePrice[_asset] = _price;\n    }\n}\n"
    },
    "contracts/core/Oracle.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity =0.6.10;\n\nimport {OpynPricerInterface} from \"../interfaces/OpynPricerInterface.sol\";\nimport {Ownable} from \"../packages/oz/Ownable.sol\";\nimport {SafeMath} from \"../packages/oz/SafeMath.sol\";\n\n/**\n * @author Opyn Team\n * @title Oracle Module\n * @notice The Oracle module sets, retrieves, and stores USD prices (USD per asset) for underlying, collateral, and strike assets\n * manages pricers that are used for different assets\n */\ncontract Oracle is Ownable {\n    using SafeMath for uint256;\n\n    /// @dev structure that stores price of asset and timestamp when the price was stored\n    struct Price {\n        uint256 price;\n        uint256 timestamp; // timestamp at which the price is pushed to this oracle\n    }\n\n    //// @dev disputer is a role defined by the owner that has the ability to dispute a price during the dispute period\n    address internal disputer;\n\n    bool migrated;\n\n    /// @dev mapping of asset pricer to its locking period\n    /// locking period is the period of time after the expiry timestamp where a price can not be pushed\n    mapping(address => uint256) internal pricerLockingPeriod;\n    /// @dev mapping of asset pricer to its dispute period\n    /// dispute period is the period of time after an expiry price has been pushed where a price can be disputed\n    mapping(address => uint256) internal pricerDisputePeriod;\n    /// @dev mapping between an asset and its pricer\n    mapping(address => address) internal assetPricer;\n    /// @dev mapping between asset, expiry timestamp, and the Price structure at the expiry timestamp\n    mapping(address => mapping(uint256 => Price)) internal storedPrice;\n    /// @dev mapping between stable asset and price\n    mapping(address => uint256) internal stablePrice;\n\n    /// @notice emits an event when the disputer is updated\n    event DisputerUpdated(address indexed newDisputer);\n    /// @notice emits an event when the pricer is updated for an asset\n    event PricerUpdated(address indexed asset, address indexed pricer);\n    /// @notice emits an event when the locking period is updated for a pricer\n    event PricerLockingPeriodUpdated(address indexed pricer, uint256 lockingPeriod);\n    /// @notice emits an event when the dispute period is updated for a pricer\n    event PricerDisputePeriodUpdated(address indexed pricer, uint256 disputePeriod);\n    /// @notice emits an event when an expiry price is updated for a specific asset\n    event ExpiryPriceUpdated(\n        address indexed asset,\n        uint256 indexed expiryTimestamp,\n        uint256 price,\n        uint256 onchainTimestamp\n    );\n    /// @notice emits an event when the disputer disputes a price during the dispute period\n    event ExpiryPriceDisputed(\n        address indexed asset,\n        uint256 indexed expiryTimestamp,\n        uint256 disputedPrice,\n        uint256 newPrice,\n        uint256 disputeTimestamp\n    );\n    /// @notice emits an event when a stable asset price changes\n    event StablePriceUpdated(address indexed asset, uint256 price);\n\n    /**\n     * @notice function to migrate asset prices from old oracle to new deployed oracle\n     * @dev this can only be called by owner, should be used at the deployment time before setting Oracle module into AddressBook\n     * @param _asset asset address\n     * @param _expiries array of expiries timestamps\n     * @param _prices array of prices\n     */\n    function migrateOracle(\n        address _asset,\n        uint256[] calldata _expiries,\n        uint256[] calldata _prices\n    ) external onlyOwner {\n        require(!migrated, \"Oracle: migration already done\");\n        require(_expiries.length == _prices.length, \"Oracle: invalid migration data\");\n\n        for (uint256 i; i < _expiries.length; i++) {\n            storedPrice[_asset][_expiries[i]] = Price(_prices[i], now);\n        }\n    }\n\n    /**\n     * @notice end migration process\n     * @dev can only be called by owner, should be called before setting Oracle module into AddressBook\n     */\n    function endMigration() external onlyOwner {\n        migrated = true;\n    }\n\n    /**\n     * @notice sets the pricer for an asset\n     * @dev can only be called by the owner\n     * @param _asset asset address\n     * @param _pricer pricer address\n     */\n    function setAssetPricer(address _asset, address _pricer) external onlyOwner {\n        require(_pricer != address(0), \"Oracle: cannot set pricer to address(0)\");\n        require(stablePrice[_asset] == 0, \"Oracle: could not set a pricer for stable asset\");\n\n        assetPricer[_asset] = _pricer;\n\n        emit PricerUpdated(_asset, _pricer);\n    }\n\n    /**\n     * @notice sets the locking period for a pricer\n     * @dev can only be called by the owner\n     * @param _pricer pricer address\n     * @param _lockingPeriod locking period\n     */\n    function setLockingPeriod(address _pricer, uint256 _lockingPeriod) external onlyOwner {\n        pricerLockingPeriod[_pricer] = _lockingPeriod;\n\n        emit PricerLockingPeriodUpdated(_pricer, _lockingPeriod);\n    }\n\n    /**\n     * @notice sets the dispute period for a pricer\n     * @dev can only be called by the owner\n     * for a composite pricer (ie CompoundPricer) that depends on or calls other pricers, ensure\n     * that the dispute period for the composite pricer is longer than the dispute period for the\n     * asset pricer that it calls to ensure safe usage as a dispute in the other pricer will cause\n     * the need for a dispute with the composite pricer's price\n     * @param _pricer pricer address\n     * @param _disputePeriod dispute period\n     */\n    function setDisputePeriod(address _pricer, uint256 _disputePeriod) external onlyOwner {\n        pricerDisputePeriod[_pricer] = _disputePeriod;\n\n        emit PricerDisputePeriodUpdated(_pricer, _disputePeriod);\n    }\n\n    /**\n     * @notice set the disputer address\n     * @dev can only be called by the owner\n     * @param _disputer disputer address\n     */\n    function setDisputer(address _disputer) external onlyOwner {\n        disputer = _disputer;\n\n        emit DisputerUpdated(_disputer);\n    }\n\n    /**\n     * @notice set stable asset price\n     * @dev price should be scaled by 1e8\n     * @param _asset asset address\n     * @param _price price\n     */\n    function setStablePrice(address _asset, uint256 _price) external onlyOwner {\n        require(assetPricer[_asset] == address(0), \"Oracle: could not set stable price for an asset with pricer\");\n\n        stablePrice[_asset] = _price;\n\n        emit StablePriceUpdated(_asset, _price);\n    }\n\n    /**\n     * @notice dispute an asset price during the dispute period\n     * @dev only the disputer can dispute a price during the dispute period, by setting a new one\n     * @param _asset asset address\n     * @param _expiryTimestamp expiry timestamp\n     * @param _price the correct price\n     */\n    function disputeExpiryPrice(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _price\n    ) external {\n        require(msg.sender == disputer, \"Oracle: caller is not the disputer\");\n        require(!isDisputePeriodOver(_asset, _expiryTimestamp), \"Oracle: dispute period over\");\n\n        Price storage priceToUpdate = storedPrice[_asset][_expiryTimestamp];\n\n        require(priceToUpdate.timestamp != 0, \"Oracle: price to dispute does not exist\");\n\n        uint256 oldPrice = priceToUpdate.price;\n        priceToUpdate.price = _price;\n\n        emit ExpiryPriceDisputed(_asset, _expiryTimestamp, oldPrice, _price, now);\n    }\n\n    /**\n     * @notice submits the expiry price to the oracle, can only be set from the pricer\n     * @dev asset price can only be set after the locking period is over and before the dispute period has started\n     * @param _asset asset address\n     * @param _expiryTimestamp expiry timestamp\n     * @param _price asset price at expiry\n     */\n    function setExpiryPrice(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _price\n    ) external {\n        require(msg.sender == assetPricer[_asset], \"Oracle: caller is not authorized to set expiry price\");\n        require(isLockingPeriodOver(_asset, _expiryTimestamp), \"Oracle: locking period is not over yet\");\n        require(storedPrice[_asset][_expiryTimestamp].timestamp == 0, \"Oracle: dispute period started\");\n\n        storedPrice[_asset][_expiryTimestamp] = Price(_price, now);\n        emit ExpiryPriceUpdated(_asset, _expiryTimestamp, _price, now);\n    }\n\n    /**\n     * @notice get a live asset price from the asset's pricer contract\n     * @param _asset asset address\n     * @return price scaled by 1e8, denominated in USD\n     * e.g. 17568900000 => 175.689 USD\n     */\n    function getPrice(address _asset) external view returns (uint256) {\n        uint256 price = stablePrice[_asset];\n\n        if (price == 0) {\n            require(assetPricer[_asset] != address(0), \"Oracle: Pricer for this asset not set\");\n\n            price = OpynPricerInterface(assetPricer[_asset]).getPrice();\n        }\n\n        return price;\n    }\n\n    /**\n     * @notice get the asset price at specific expiry timestamp\n     * @param _asset asset address\n     * @param _expiryTimestamp expiry timestamp\n     * @return price scaled by 1e8, denominated in USD\n     * @return isFinalized True, if the price is finalized, False if not\n     */\n    function getExpiryPrice(address _asset, uint256 _expiryTimestamp) external view returns (uint256, bool) {\n        uint256 price = stablePrice[_asset];\n        bool isFinalized = true;\n\n        if (price == 0) {\n            price = storedPrice[_asset][_expiryTimestamp].price;\n            isFinalized = isDisputePeriodOver(_asset, _expiryTimestamp);\n        }\n\n        return (price, isFinalized);\n    }\n\n    /**\n     * @notice get the pricer for an asset\n     * @param _asset asset address\n     * @return pricer address\n     */\n    function getPricer(address _asset) external view returns (address) {\n        return assetPricer[_asset];\n    }\n\n    /**\n     * @notice get the disputer address\n     * @return disputer address\n     */\n    function getDisputer() external view returns (address) {\n        return disputer;\n    }\n\n    /**\n     * @notice get a pricer's locking period\n     * locking period is the period of time after the expiry timestamp where a price can not be pushed\n     * @dev during the locking period an expiry price can not be submitted to this contract\n     * @param _pricer pricer address\n     * @return locking period\n     */\n    function getPricerLockingPeriod(address _pricer) external view returns (uint256) {\n        return pricerLockingPeriod[_pricer];\n    }\n\n    /**\n     * @notice get a pricer's dispute period\n     * dispute period is the period of time after an expiry price has been pushed where a price can be disputed\n     * @dev during the dispute period, the disputer can dispute the submitted price and modify it\n     * @param _pricer pricer address\n     * @return dispute period\n     */\n    function getPricerDisputePeriod(address _pricer) external view returns (uint256) {\n        return pricerDisputePeriod[_pricer];\n    }\n\n    /**\n     * @notice get historical asset price and timestamp\n     * @dev if asset is a stable asset, will return stored price and timestamp equal to now\n     * @param _asset asset address to get it's historical price\n     * @param _roundId chainlink round id\n     * @return price and round timestamp\n     */\n    function getChainlinkRoundData(address _asset, uint80 _roundId) external view returns (uint256, uint256) {\n        uint256 price = stablePrice[_asset];\n        uint256 timestamp = now;\n\n        if (price == 0) {\n            require(assetPricer[_asset] != address(0), \"Oracle: Pricer for this asset not set\");\n\n            (price, timestamp) = OpynPricerInterface(assetPricer[_asset]).getHistoricalPrice(_roundId);\n        }\n\n        return (price, timestamp);\n    }\n\n    /**\n     * @notice check if the locking period is over for setting the asset price at a particular expiry timestamp\n     * @param _asset asset address\n     * @param _expiryTimestamp expiry timestamp\n     * @return True if locking period is over, False if not\n     */\n    function isLockingPeriodOver(address _asset, uint256 _expiryTimestamp) public view returns (bool) {\n        uint256 price = stablePrice[_asset];\n\n        if (price == 0) {\n            address pricer = assetPricer[_asset];\n            uint256 lockingPeriod = pricerLockingPeriod[pricer];\n\n            return now > _expiryTimestamp.add(lockingPeriod);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice check if the dispute period is over\n     * @param _asset asset address\n     * @param _expiryTimestamp expiry timestamp\n     * @return True if dispute period is over, False if not\n     */\n    function isDisputePeriodOver(address _asset, uint256 _expiryTimestamp) public view returns (bool) {\n        uint256 price = stablePrice[_asset];\n\n        if (price == 0) {\n            // check if the pricer has a price for this expiry timestamp\n            Price memory price = storedPrice[_asset][_expiryTimestamp];\n            if (price.timestamp == 0) {\n                return false;\n            }\n\n            address pricer = assetPricer[_asset];\n            uint256 disputePeriod = pricerDisputePeriod[pricer];\n\n            return now > price.timestamp.add(disputePeriod);\n        }\n\n        return true;\n    }\n}\n"
    },
    "contracts/pricers/CompoundPricer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\nimport {OracleInterface} from \"../interfaces/OracleInterface.sol\";\nimport {CTokenInterface} from \"../interfaces/CTokenInterface.sol\";\nimport {ERC20Interface} from \"../interfaces/ERC20Interface.sol\";\nimport {SafeMath} from \"../packages/oz/SafeMath.sol\";\n\n/**\n * @notice A Pricer contract for a Compound cToken\n */\ncontract CompoundPricer {\n    using SafeMath for uint256;\n\n    /// @notice opyn oracle address\n    OracleInterface public oracle;\n\n    /// @notice cToken that this pricer will a get price for\n    CTokenInterface public cToken;\n\n    /// @notice underlying asset for this cToken\n    ERC20Interface public underlying;\n\n    /**\n     * @param _cToken cToken asset\n     * @param _underlying underlying asset for this cToken\n     * @param _oracle Opyn Oracle contract address\n     */\n    constructor(\n        address _cToken,\n        address _underlying,\n        address _oracle\n    ) public {\n        require(_cToken != address(0), \"CompoundPricer: cToken address can not be 0\");\n        require(_underlying != address(0), \"CompoundPricer: underlying address can not be 0\");\n        require(_oracle != address(0), \"CompoundPricer: oracle address can not be 0\");\n\n        cToken = CTokenInterface(_cToken);\n        underlying = ERC20Interface(_underlying);\n        oracle = OracleInterface(_oracle);\n    }\n\n    /**\n     * @notice get the live price for the asset\n     * @return price of 1e8 cToken in USD, scaled by 1e8\n     */\n    function getPrice() external view returns (uint256) {\n        uint256 underlyingPrice = oracle.getPrice(address(underlying));\n        require(underlyingPrice > 0, \"CompoundPricer: underlying price is 0\");\n        return _underlyingPriceToCtokenPrice(underlyingPrice);\n    }\n\n    /**\n     * @notice set the expiry price in the oracle\n     * @dev requires that the underlying price has been set before setting a cToken price\n     * @param _expiryTimestamp expiry to set a price for\n     */\n    function setExpiryPriceInOracle(uint256 _expiryTimestamp) external {\n        (uint256 underlyingPriceExpiry, ) = oracle.getExpiryPrice(address(underlying), _expiryTimestamp);\n        require(underlyingPriceExpiry > 0, \"CompoundPricer: underlying price not set yet\");\n        uint256 cTokenPrice = _underlyingPriceToCtokenPrice(underlyingPriceExpiry);\n        oracle.setExpiryPrice(address(cToken), _expiryTimestamp, cTokenPrice);\n    }\n\n    /**\n     * @dev convert underlying price to cToken price with the cToken to underlying exchange rate\n     * @param _underlyingPrice price of 1 underlying token (ie 1e6 USDC, 1e18 WETH) in USD, scaled by 1e8\n     * @return price of 1e8 cToken in USD, scaled by 1e8\n     */\n    function _underlyingPriceToCtokenPrice(uint256 _underlyingPrice) internal view returns (uint256) {\n        uint256 underlyingDecimals = uint256(underlying.decimals());\n        uint256 cTokenDecimals = uint256(cToken.decimals());\n        uint256 exchangeRate = cToken.exchangeRateStored();\n        return exchangeRate.mul(_underlyingPrice).mul(10**(cTokenDecimals)).div(10**(underlyingDecimals.add(18)));\n    }\n}\n"
    },
    "contracts/interfaces/CTokenInterface.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\n/**\n * @dev Interface of Compound cToken\n */\ninterface CTokenInterface {\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() external view returns (uint256);\n\n    function decimals() external view returns (uint256);\n}\n"
    },
    "contracts/mocks/MockPricer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\nimport {OracleInterface} from \"../interfaces/OracleInterface.sol\";\n\ncontract MockPricer {\n    OracleInterface public oracle;\n\n    uint256 internal price;\n    address public asset;\n\n    constructor(address _asset, address _oracle) public {\n        asset = _asset;\n        oracle = OracleInterface(_oracle);\n    }\n\n    function setPrice(uint256 _price) external {\n        price = _price;\n    }\n\n    function getPrice() external view returns (uint256) {\n        return price;\n    }\n\n    function setExpiryPriceInOracle(uint256 _expiryTimestamp, uint256 _price) external {\n        oracle.setExpiryPrice(asset, _expiryTimestamp, _price);\n    }\n\n    function getHistoricalPrice(uint80 _roundId) external view returns (uint256, uint256) {\n        return (price, now);\n    }\n}\n"
    },
    "contracts/core/MarginCalculator.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity =0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"../packages/oz/SafeMath.sol\";\nimport {Ownable} from \"../packages/oz/Ownable.sol\";\nimport {OtokenInterface} from \"../interfaces/OtokenInterface.sol\";\nimport {OracleInterface} from \"../interfaces/OracleInterface.sol\";\nimport {ERC20Interface} from \"../interfaces/ERC20Interface.sol\";\nimport {FixedPointInt256 as FPI} from \"../libs/FixedPointInt256.sol\";\nimport {MarginVault} from \"../libs/MarginVault.sol\";\n\n/**\n * @title MarginCalculator\n * @author Opyn\n * @notice Calculator module that checks if a given vault is valid, calculates margin requirements, and settlement proceeds\n */\ncontract MarginCalculator is Ownable {\n    using SafeMath for uint256;\n    using FPI for FPI.FixedPointInt;\n\n    /// @dev decimals option upper bound value, spot shock and oracle deviation\n    uint256 internal constant SCALING_FACTOR = 27;\n\n    /// @dev decimals used by strike price and oracle price\n    uint256 internal constant BASE = 8;\n\n    /// @notice auction length\n    uint256 public constant AUCTION_TIME = 3600;\n\n    /// @dev struct to store all needed vault details\n    struct VaultDetails {\n        address shortUnderlyingAsset;\n        address shortStrikeAsset;\n        address shortCollateralAsset;\n        address longUnderlyingAsset;\n        address longStrikeAsset;\n        address longCollateralAsset;\n        uint256 shortStrikePrice;\n        uint256 shortExpiryTimestamp;\n        uint256 shortCollateralDecimals;\n        uint256 longStrikePrice;\n        uint256 longExpiryTimestamp;\n        uint256 longCollateralDecimals;\n        uint256 collateralDecimals;\n        uint256 vaultType;\n        bool isShortPut;\n        bool isLongPut;\n        bool hasLong;\n        bool hasShort;\n        bool hasCollateral;\n    }\n\n    /// @dev oracle deviation value (1e27)\n    uint256 internal oracleDeviation;\n\n    /// @dev FixedPoint 0\n    FPI.FixedPointInt internal ZERO = FPI.fromScaledUint(0, BASE);\n\n    /// @dev mapping to store dust amount per option collateral asset (scaled by collateral asset decimals)\n    mapping(address => uint256) internal dust;\n\n    /// @dev mapping to store array of time to expiry for a given product\n    mapping(bytes32 => uint256[]) internal timesToExpiryForProduct;\n\n    /// @dev mapping to store option upper bound value at specific time to expiry for a given product (1e27)\n    mapping(bytes32 => mapping(uint256 => uint256)) internal maxPriceAtTimeToExpiry;\n\n    /// @dev mapping to store shock value for spot price of a given product (1e27)\n    mapping(bytes32 => uint256) internal spotShock;\n\n    /// @dev oracle module\n    OracleInterface public oracle;\n\n    /// @notice emits an event when collateral dust is updated\n    event CollateralDustUpdated(address indexed collateral, uint256 dust);\n    /// @notice emits an event when new time to expiry is added for a specific product\n    event TimeToExpiryAdded(bytes32 indexed productHash, uint256 timeToExpiry);\n    /// @notice emits an event when new upper bound value is added for a specific time to expiry timestamp\n    event MaxPriceAdded(bytes32 indexed productHash, uint256 timeToExpiry, uint256 value);\n    /// @notice emits an event when updating upper bound value at specific expiry timestamp\n    event MaxPriceUpdated(bytes32 indexed productHash, uint256 timeToExpiry, uint256 oldValue, uint256 newValue);\n    /// @notice emits an event when spot shock value is updated for a specific product\n    event SpotShockUpdated(bytes32 indexed product, uint256 spotShock);\n    /// @notice emits an event when oracle deviation value is updated\n    event OracleDeviationUpdated(uint256 oracleDeviation);\n\n    /**\n     * @notice constructor\n     * @param _oracle oracle module address\n     */\n    constructor(address _oracle) public {\n        require(_oracle != address(0), \"MarginCalculator: invalid oracle address\");\n\n        oracle = OracleInterface(_oracle);\n    }\n\n    /**\n     * @notice set dust amount for collateral asset\n     * @dev can only be called by owner\n     * @param _collateral collateral asset address\n     * @param _dust dust amount, should be scaled by collateral asset decimals\n     */\n    function setCollateralDust(address _collateral, uint256 _dust) external onlyOwner {\n        require(_dust > 0, \"MarginCalculator: dust amount should be greater than zero\");\n\n        dust[_collateral] = _dust;\n\n        emit CollateralDustUpdated(_collateral, _dust);\n    }\n\n    /**\n     * @notice set product upper bound values\n     * @dev can only be called by owner\n     * @param _underlying otoken underlying asset\n     * @param _strike otoken strike asset\n     * @param _collateral otoken collateral asset\n     * @param _isPut otoken type\n     * @param _timesToExpiry array of times to expiry timestamp\n     * @param _values upper bound values array\n     */\n    function setUpperBoundValues(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut,\n        uint256[] calldata _timesToExpiry,\n        uint256[] calldata _values\n    ) external onlyOwner {\n        require(_timesToExpiry.length > 0, \"MarginCalculator: invalid times to expiry array\");\n        require(_timesToExpiry.length == _values.length, \"MarginCalculator: invalid values array\");\n\n        // get product hash\n        bytes32 productHash = _getProductHash(_underlying, _strike, _collateral, _isPut);\n\n        uint256[] storage expiryArray = timesToExpiryForProduct[productHash];\n\n        // check that this is the first expiry to set\n        // if not, the last expiry should be less than the new one to insert (to make sure the array stay in order)\n        require(\n            (expiryArray.length == 0) || (_timesToExpiry[0] > expiryArray[expiryArray.length.sub(1)]),\n            \"MarginCalculator: expiry array is not in order\"\n        );\n\n        for (uint256 i = 0; i < _timesToExpiry.length; i++) {\n            // check that new times array is in order\n            if (i.add(1) < _timesToExpiry.length) {\n                require(_timesToExpiry[i] < _timesToExpiry[i.add(1)], \"MarginCalculator: time should be in order\");\n            }\n\n            require(_values[i] > 0, \"MarginCalculator: no expiry upper bound value found\");\n\n            // add new upper bound value for this product at specific time to expiry\n            maxPriceAtTimeToExpiry[productHash][_timesToExpiry[i]] = _values[i];\n\n            // add new time to expiry to array\n            expiryArray.push(_timesToExpiry[i]);\n\n            emit TimeToExpiryAdded(productHash, _timesToExpiry[i]);\n            emit MaxPriceAdded(productHash, _timesToExpiry[i], _values[i]);\n        }\n    }\n\n    /**\n     * @notice set option upper bound value for specific time to expiry (1e27)\n     * @dev can only be called by owner\n     * @param _underlying otoken underlying asset\n     * @param _strike otoken strike asset\n     * @param _collateral otoken collateral asset\n     * @param _isPut otoken type\n     * @param _timeToExpiry option time to expiry timestamp\n     * @param _value upper bound value\n     */\n    function updateUpperBoundValue(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut,\n        uint256 _timeToExpiry,\n        uint256 _value\n    ) external onlyOwner {\n        require(_value > 0, \"MarginCalculator: invalid option upper bound value\");\n\n        bytes32 productHash = _getProductHash(_underlying, _strike, _collateral, _isPut);\n        uint256 oldMaxPrice = maxPriceAtTimeToExpiry[productHash][_timeToExpiry];\n\n        require(oldMaxPrice != 0, \"MarginCalculator: upper bound value not found\");\n\n        // update upper bound value for the time to expiry\n        maxPriceAtTimeToExpiry[productHash][_timeToExpiry] = _value;\n\n        emit MaxPriceUpdated(productHash, _timeToExpiry, oldMaxPrice, _value);\n    }\n\n    /**\n     * @notice set spot shock value, scaled to 1e27\n     * @dev can only be called by owner\n     * @param _underlying otoken underlying asset\n     * @param _strike otoken strike asset\n     * @param _collateral otoken collateral asset\n     * @param _isPut otoken type\n     * @param _shockValue spot shock value\n     */\n    function setSpotShock(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut,\n        uint256 _shockValue\n    ) external onlyOwner {\n        require(_shockValue > 0, \"MarginCalculator: invalid spot shock value\");\n\n        bytes32 productHash = _getProductHash(_underlying, _strike, _collateral, _isPut);\n\n        spotShock[productHash] = _shockValue;\n\n        emit SpotShockUpdated(productHash, _shockValue);\n    }\n\n    /**\n     * @notice set oracle deviation (1e27)\n     * @dev can only be called by owner\n     * @param _deviation deviation value\n     */\n    function setOracleDeviation(uint256 _deviation) external onlyOwner {\n        oracleDeviation = _deviation;\n\n        emit OracleDeviationUpdated(_deviation);\n    }\n\n    /**\n     * @notice get dust amount for collateral asset\n     * @param _collateral collateral asset address\n     * @return dust amount\n     */\n    function getCollateralDust(address _collateral) external view returns (uint256) {\n        return dust[_collateral];\n    }\n\n    /**\n     * @notice get times to expiry for a specific product\n     * @param _underlying otoken underlying asset\n     * @param _strike otoken strike asset\n     * @param _collateral otoken collateral asset\n     * @param _isPut otoken type\n     * @return array of times to expiry\n     */\n    function getTimesToExpiry(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external view returns (uint256[] memory) {\n        bytes32 productHash = _getProductHash(_underlying, _strike, _collateral, _isPut);\n        return timesToExpiryForProduct[productHash];\n    }\n\n    /**\n     * @notice get option upper bound value for specific time to expiry\n     * @param _underlying otoken underlying asset\n     * @param _strike otoken strike asset\n     * @param _collateral otoken collateral asset\n     * @param _isPut otoken type\n     * @param _timeToExpiry option time to expiry timestamp\n     * @return option upper bound value (1e27)\n     */\n    function getMaxPrice(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut,\n        uint256 _timeToExpiry\n    ) external view returns (uint256) {\n        bytes32 productHash = _getProductHash(_underlying, _strike, _collateral, _isPut);\n\n        return maxPriceAtTimeToExpiry[productHash][_timeToExpiry];\n    }\n\n    /**\n     * @notice get spot shock value\n     * @param _underlying otoken underlying asset\n     * @param _strike otoken strike asset\n     * @param _collateral otoken collateral asset\n     * @param _isPut otoken type\n     * @return _shockValue spot shock value (1e27)\n     */\n    function getSpotShock(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external view returns (uint256) {\n        bytes32 productHash = _getProductHash(_underlying, _strike, _collateral, _isPut);\n\n        return spotShock[productHash];\n    }\n\n    /**\n     * @notice get oracle deviation\n     * @return oracle deviation value (1e27)\n     */\n    function getOracleDeviation() external view returns (uint256) {\n        return oracleDeviation;\n    }\n\n    /**\n     * @notice return the collateral required for naked margin vault, in collateral asset decimals\n     * @dev _shortAmount, _strikePrice and _underlyingPrice should be scaled by 1e8\n     * @param _underlying underlying asset address\n     * @param _strike strike asset address\n     * @param _collateral collateral asset address\n     * @param _shortAmount amount of short otoken\n     * @param  _strikePrice otoken strike price\n     * @param _underlyingPrice otoken underlying price\n     * @param _shortExpiryTimestamp otoken expiry timestamp\n     * @param _collateralDecimals otoken collateral asset decimals\n     * @param _isPut otoken type\n     * @return collateral required for a naked margin vault, in collateral asset decimals\n     */\n    function getNakedMarginRequired(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        uint256 _shortAmount,\n        uint256 _strikePrice,\n        uint256 _underlyingPrice,\n        uint256 _shortExpiryTimestamp,\n        uint256 _collateralDecimals,\n        bool _isPut\n    ) external view returns (uint256) {\n        bytes32 productHash = _getProductHash(_underlying, _strike, _collateral, _isPut);\n\n        // scale short amount from 1e8 to 1e27 (oToken is always in 1e8)\n        FPI.FixedPointInt memory shortAmount = FPI.fromScaledUint(_shortAmount, BASE);\n        // scale short strike from 1e8 to 1e27\n        FPI.FixedPointInt memory shortStrike = FPI.fromScaledUint(_strikePrice, BASE);\n        // scale short underlying price from 1e8 to 1e27\n        FPI.FixedPointInt memory shortUnderlyingPrice = FPI.fromScaledUint(_underlyingPrice, BASE);\n\n        // return required margin, scaled by collateral asset decimals, explicitly rounded up\n        return\n            FPI.toScaledUint(\n                _getNakedMarginRequired(\n                    productHash,\n                    shortAmount,\n                    shortUnderlyingPrice,\n                    shortStrike,\n                    _shortExpiryTimestamp,\n                    _isPut\n                ),\n                _collateralDecimals,\n                false\n            );\n    }\n\n    /**\n     * @notice return the cash value of an expired oToken, denominated in collateral\n     * @param _otoken oToken address\n     * @return how much collateral can be taken out by 1 otoken unit, scaled by 1e8,\n     * or how much collateral can be taken out for 1 (1e8) oToken\n     */\n    function getExpiredPayoutRate(address _otoken) external view returns (uint256) {\n        require(_otoken != address(0), \"MarginCalculator: Invalid token address\");\n\n        (\n            address collateral,\n            address underlying,\n            address strikeAsset,\n            uint256 strikePrice,\n            uint256 expiry,\n            bool isPut\n        ) = _getOtokenDetails(_otoken);\n\n        require(now >= expiry, \"MarginCalculator: Otoken not expired yet\");\n\n        FPI.FixedPointInt memory cashValueInStrike = _getExpiredCashValue(\n            underlying,\n            strikeAsset,\n            expiry,\n            strikePrice,\n            isPut\n        );\n\n        FPI.FixedPointInt memory cashValueInCollateral = _convertAmountOnExpiryPrice(\n            cashValueInStrike,\n            strikeAsset,\n            collateral,\n            expiry\n        );\n\n        // the exchangeRate was scaled by 1e8, if 1e8 otoken can take out 1 USDC, the exchangeRate is currently 1e8\n        // we want to return: how much USDC units can be taken out by 1 (1e8 units) oToken\n        uint256 collateralDecimals = uint256(ERC20Interface(collateral).decimals());\n        return cashValueInCollateral.toScaledUint(collateralDecimals, true);\n    }\n\n    // structs to avoid stack too deep error\n    // struct to store shortAmount, shortStrike and shortUnderlyingPrice scaled to 1e27\n    struct ShortScaledDetails {\n        FPI.FixedPointInt shortAmount;\n        FPI.FixedPointInt shortStrike;\n        FPI.FixedPointInt shortUnderlyingPrice;\n    }\n\n    /**\n     * @notice check if a specific vault is undercollateralized at a specific chainlink round\n     * @dev if the vault is of type 0, the function will revert\n     * @param _vault vault struct\n     * @param _vaultType vault type (0 for max loss/spread and 1 for naked margin vault)\n     * @param _vaultLatestUpdate vault latest update (timestamp when latest vault state change happened)\n     * @param _roundId chainlink round id\n     * @return isLiquidatable, true if vault is undercollateralized, liquidation price and collateral dust amount\n     */\n    function isLiquidatable(\n        MarginVault.Vault memory _vault,\n        uint256 _vaultType,\n        uint256 _vaultLatestUpdate,\n        uint256 _roundId\n    )\n        external\n        view\n        returns (\n            bool,\n            uint256,\n            uint256\n        )\n    {\n        // liquidation is only supported for naked margin vault\n        require(_vaultType == 1, \"MarginCalculator: invalid vault type to liquidate\");\n\n        VaultDetails memory vaultDetails = _getVaultDetails(_vault, _vaultType);\n\n        // can not liquidate vault that have no short position\n        if (!vaultDetails.hasShort) return (false, 0, 0);\n\n        require(now < vaultDetails.shortExpiryTimestamp, \"MarginCalculator: can not liquidate expired position\");\n\n        (uint256 price, uint256 timestamp) = oracle.getChainlinkRoundData(\n            vaultDetails.shortUnderlyingAsset,\n            uint80(_roundId)\n        );\n\n        // check that price timestamp is after latest timestamp the vault was updated at\n        require(\n            timestamp > _vaultLatestUpdate,\n            \"MarginCalculator: auction timestamp should be post vault latest update\"\n        );\n\n        // another struct to store some useful short otoken details, to avoid stack to deep error\n        ShortScaledDetails memory shortDetails = ShortScaledDetails({\n            shortAmount: FPI.fromScaledUint(_vault.shortAmounts[0], BASE),\n            shortStrike: FPI.fromScaledUint(vaultDetails.shortStrikePrice, BASE),\n            shortUnderlyingPrice: FPI.fromScaledUint(price, BASE)\n        });\n\n        bytes32 productHash = _getProductHash(\n            vaultDetails.shortUnderlyingAsset,\n            vaultDetails.shortStrikeAsset,\n            vaultDetails.shortCollateralAsset,\n            vaultDetails.isShortPut\n        );\n\n        // convert vault collateral to a fixed point (1e27) from collateral decimals\n        FPI.FixedPointInt memory depositedCollateral = FPI.fromScaledUint(\n            _vault.collateralAmounts[0],\n            vaultDetails.collateralDecimals\n        );\n\n        FPI.FixedPointInt memory collateralRequired = _getNakedMarginRequired(\n            productHash,\n            shortDetails.shortAmount,\n            shortDetails.shortUnderlyingPrice,\n            shortDetails.shortStrike,\n            vaultDetails.shortExpiryTimestamp,\n            vaultDetails.isShortPut\n        );\n\n        // if collateral required <= collateral in the vault, the vault is not liquidatable\n        if (collateralRequired.isLessThanOrEqual(depositedCollateral)) {\n            return (false, 0, 0);\n        }\n\n        FPI.FixedPointInt memory cashValue = _getCashValue(\n            shortDetails.shortStrike,\n            shortDetails.shortUnderlyingPrice,\n            vaultDetails.isShortPut\n        );\n\n        // get the amount of collateral per 1 repaid otoken\n        uint256 debtPrice = _getDebtPrice(\n            depositedCollateral,\n            shortDetails.shortAmount,\n            cashValue,\n            shortDetails.shortUnderlyingPrice,\n            timestamp,\n            vaultDetails.collateralDecimals,\n            vaultDetails.isShortPut\n        );\n\n        return (true, debtPrice, dust[vaultDetails.shortCollateralAsset]);\n    }\n\n    /**\n     * @notice calculate required collateral margin for a vault\n     * @param _vault theoretical vault that needs to be checked\n     * @param _vaultType vault type\n     * @return the vault collateral amount, and marginRequired the minimal amount of collateral needed in a vault, scaled to 1e27\n     */\n    function getMarginRequired(MarginVault.Vault memory _vault, uint256 _vaultType)\n        external\n        view\n        returns (FPI.FixedPointInt memory, FPI.FixedPointInt memory)\n    {\n        VaultDetails memory vaultDetail = _getVaultDetails(_vault, _vaultType);\n        return _getMarginRequired(_vault, vaultDetail);\n    }\n\n    /**\n     * @notice returns the amount of collateral that can be removed from an actual or a theoretical vault\n     * @dev return amount is denominated in the collateral asset for the oToken in the vault, or the collateral asset in the vault\n     * @param _vault theoretical vault that needs to be checked\n     * @param _vaultType vault type (0 for spread/max loss, 1 for naked margin)\n     * @return excessCollateral the amount by which the margin is above or below the required amount\n     * @return isExcess True if there is excess margin in the vault, False if there is a deficit of margin in the vault\n     * if True, collateral can be taken out from the vault, if False, additional collateral needs to be added to vault\n     */\n    function getExcessCollateral(MarginVault.Vault memory _vault, uint256 _vaultType)\n        public\n        view\n        returns (uint256, bool)\n    {\n        VaultDetails memory vaultDetails = _getVaultDetails(_vault, _vaultType);\n\n        // include all the checks for to ensure the vault is valid\n        _checkIsValidVault(_vault, vaultDetails);\n\n        // if the vault contains no oTokens, return the amount of collateral\n        if (!vaultDetails.hasShort && !vaultDetails.hasLong) {\n            uint256 amount = vaultDetails.hasCollateral ? _vault.collateralAmounts[0] : 0;\n            return (amount, true);\n        }\n\n        // get required margin, denominated in collateral, scaled in 1e27\n        (FPI.FixedPointInt memory collateralAmount, FPI.FixedPointInt memory collateralRequired) = _getMarginRequired(\n            _vault,\n            vaultDetails\n        );\n        FPI.FixedPointInt memory excessCollateral = collateralAmount.sub(collateralRequired);\n\n        bool isExcess = excessCollateral.isGreaterThanOrEqual(ZERO);\n        uint256 collateralDecimals = vaultDetails.hasLong\n            ? vaultDetails.longCollateralDecimals\n            : vaultDetails.shortCollateralDecimals;\n        // if is excess, truncate the tailing digits in excessCollateralExternal calculation\n        uint256 excessCollateralExternal = excessCollateral.toScaledUint(collateralDecimals, isExcess);\n        return (excessCollateralExternal, isExcess);\n    }\n\n    /**\n     * @notice return the cash value of an expired oToken, denominated in strike asset\n     * @dev for a call, return Max (0, underlyingPriceInStrike - otoken.strikePrice)\n     * @dev for a put, return Max(0, otoken.strikePrice - underlyingPriceInStrike)\n     * @param _underlying otoken underlying asset\n     * @param _strike otoken strike asset\n     * @param _expiryTimestamp otoken expiry timestamp\n     * @param _strikePrice otoken strike price\n     * @param _strikePrice true if otoken is put otherwise false\n     * @return cash value of an expired otoken, denominated in the strike asset\n     */\n    function _getExpiredCashValue(\n        address _underlying,\n        address _strike,\n        uint256 _expiryTimestamp,\n        uint256 _strikePrice,\n        bool _isPut\n    ) internal view returns (FPI.FixedPointInt memory) {\n        // strike price is denominated in strike asset\n        FPI.FixedPointInt memory strikePrice = FPI.fromScaledUint(_strikePrice, BASE);\n        FPI.FixedPointInt memory one = FPI.fromScaledUint(1, 0);\n\n        // calculate the value of the underlying asset in terms of the strike asset\n        FPI.FixedPointInt memory underlyingPriceInStrike = _convertAmountOnExpiryPrice(\n            one, // underlying price is 1 (1e27) in term of underlying\n            _underlying,\n            _strike,\n            _expiryTimestamp\n        );\n\n        return _getCashValue(strikePrice, underlyingPriceInStrike, _isPut);\n    }\n\n    /// @dev added this struct to avoid stack-too-deep error\n    struct OtokenDetails {\n        address otokenUnderlyingAsset;\n        address otokenCollateralAsset;\n        address otokenStrikeAsset;\n        uint256 otokenExpiry;\n        bool isPut;\n    }\n\n    /**\n     * @notice calculate the amount of collateral needed for a vault\n     * @dev vault passed in has already passed the checkIsValidVault function\n     * @param _vault theoretical vault that needs to be checked\n     * @return the vault collateral amount, and marginRequired the minimal amount of collateral needed in a vault,\n     * scaled to 1e27\n     */\n    function _getMarginRequired(MarginVault.Vault memory _vault, VaultDetails memory _vaultDetails)\n        internal\n        view\n        returns (FPI.FixedPointInt memory, FPI.FixedPointInt memory)\n    {\n        FPI.FixedPointInt memory shortAmount = _vaultDetails.hasShort\n            ? FPI.fromScaledUint(_vault.shortAmounts[0], BASE)\n            : ZERO;\n        FPI.FixedPointInt memory longAmount = _vaultDetails.hasLong\n            ? FPI.fromScaledUint(_vault.longAmounts[0], BASE)\n            : ZERO;\n        FPI.FixedPointInt memory collateralAmount = _vaultDetails.hasCollateral\n            ? FPI.fromScaledUint(_vault.collateralAmounts[0], _vaultDetails.collateralDecimals)\n            : ZERO;\n        FPI.FixedPointInt memory shortStrike = _vaultDetails.hasShort\n            ? FPI.fromScaledUint(_vaultDetails.shortStrikePrice, BASE)\n            : ZERO;\n\n        // struct to avoid stack too deep error\n        OtokenDetails memory otokenDetails = OtokenDetails(\n            _vaultDetails.hasShort ? _vaultDetails.shortUnderlyingAsset : _vaultDetails.longUnderlyingAsset,\n            _vaultDetails.hasShort ? _vaultDetails.shortCollateralAsset : _vaultDetails.longCollateralAsset,\n            _vaultDetails.hasShort ? _vaultDetails.shortStrikeAsset : _vaultDetails.longStrikeAsset,\n            _vaultDetails.hasShort ? _vaultDetails.shortExpiryTimestamp : _vaultDetails.longExpiryTimestamp,\n            _vaultDetails.hasShort ? _vaultDetails.isShortPut : _vaultDetails.isLongPut\n        );\n\n        if (now < otokenDetails.otokenExpiry) {\n            // it's not expired, return amount of margin required based on vault type\n            if (_vaultDetails.vaultType == 1) {\n                // this is a naked margin vault\n                // fetch dust amount for otoken collateral asset as FixedPointInt, assuming dust is already scaled by collateral decimals\n                FPI.FixedPointInt memory dustAmount = FPI.fromScaledUint(\n                    dust[_vaultDetails.shortCollateralAsset],\n                    _vaultDetails.collateralDecimals\n                );\n\n                // check that collateral deposited in naked margin vault is greater than dust amount for that particular collateral asset\n                if (collateralAmount.isGreaterThan(ZERO)) {\n                    require(\n                        collateralAmount.isGreaterThan(dustAmount),\n                        \"MarginCalculator: naked margin vault should have collateral amount greater than dust amount\"\n                    );\n                }\n\n                // get underlying asset price for short option\n                FPI.FixedPointInt memory shortUnderlyingPrice = FPI.fromScaledUint(\n                    oracle.getPrice(_vaultDetails.shortUnderlyingAsset),\n                    BASE\n                );\n\n                // encode product hash\n                bytes32 productHash = _getProductHash(\n                    _vaultDetails.shortUnderlyingAsset,\n                    _vaultDetails.shortStrikeAsset,\n                    _vaultDetails.shortCollateralAsset,\n                    _vaultDetails.isShortPut\n                );\n\n                // return amount of collateral in vault and needed collateral amount for margin\n                return (\n                    collateralAmount,\n                    _getNakedMarginRequired(\n                        productHash,\n                        shortAmount,\n                        shortUnderlyingPrice,\n                        shortStrike,\n                        otokenDetails.otokenExpiry,\n                        otokenDetails.isPut\n                    )\n                );\n            } else {\n                // this is a fully collateralized vault\n                FPI.FixedPointInt memory longStrike = _vaultDetails.hasLong\n                    ? FPI.fromScaledUint(_vaultDetails.longStrikePrice, BASE)\n                    : ZERO;\n\n                if (otokenDetails.isPut) {\n                    FPI.FixedPointInt memory strikeNeeded = _getPutSpreadMarginRequired(\n                        shortAmount,\n                        longAmount,\n                        shortStrike,\n                        longStrike\n                    );\n                    // convert amount to be denominated in collateral\n                    return (\n                        collateralAmount,\n                        _convertAmountOnLivePrice(\n                            strikeNeeded,\n                            otokenDetails.otokenStrikeAsset,\n                            otokenDetails.otokenCollateralAsset\n                        )\n                    );\n                } else {\n                    FPI.FixedPointInt memory underlyingNeeded = _getCallSpreadMarginRequired(\n                        shortAmount,\n                        longAmount,\n                        shortStrike,\n                        longStrike\n                    );\n                    // convert amount to be denominated in collateral\n                    return (\n                        collateralAmount,\n                        _convertAmountOnLivePrice(\n                            underlyingNeeded,\n                            otokenDetails.otokenUnderlyingAsset,\n                            otokenDetails.otokenCollateralAsset\n                        )\n                    );\n                }\n            }\n        } else {\n            // the vault has expired. calculate the cash value of all the minted short options\n            FPI.FixedPointInt memory shortCashValue = _vaultDetails.hasShort\n                ? _getExpiredCashValue(\n                    _vaultDetails.shortUnderlyingAsset,\n                    _vaultDetails.shortStrikeAsset,\n                    _vaultDetails.shortExpiryTimestamp,\n                    _vaultDetails.shortStrikePrice,\n                    otokenDetails.isPut\n                )\n                : ZERO;\n            FPI.FixedPointInt memory longCashValue = _vaultDetails.hasLong\n                ? _getExpiredCashValue(\n                    _vaultDetails.longUnderlyingAsset,\n                    _vaultDetails.longStrikeAsset,\n                    _vaultDetails.longExpiryTimestamp,\n                    _vaultDetails.longStrikePrice,\n                    otokenDetails.isPut\n                )\n                : ZERO;\n\n            FPI.FixedPointInt memory valueInStrike = _getExpiredSpreadCashValue(\n                shortAmount,\n                longAmount,\n                shortCashValue,\n                longCashValue\n            );\n\n            // convert amount to be denominated in collateral\n            return (\n                collateralAmount,\n                _convertAmountOnExpiryPrice(\n                    valueInStrike,\n                    otokenDetails.otokenStrikeAsset,\n                    otokenDetails.otokenCollateralAsset,\n                    otokenDetails.otokenExpiry\n                )\n            );\n        }\n    }\n\n    /**\n     * @notice get required collateral for naked margin position\n     * if put:\n     * a = min(strike price, spot shock * underlying price)\n     * b = max(strike price - spot shock * underlying price, 0)\n     * marginRequired = ( option upper bound value * a + b) * short amount\n     * if call:\n     * a = min(1, strike price / (underlying price / spot shock value))\n     * b = max(1- (strike price / (underlying price / spot shock value)), 0)\n     * marginRequired = (option upper bound value * a + b) * short amount\n     * @param _productHash product hash\n     * @param _shortAmount short amount in vault, in FixedPointInt type\n     * @param _strikePrice strike price of short otoken, in FixedPointInt type\n     * @param _underlyingPrice underlying price of short otoken underlying asset, in FixedPointInt type\n     * @param _shortExpiryTimestamp short otoken expiry timestamp\n     * @param _isPut otoken type, true if put option, false for call option\n     * @return required margin for this naked vault, in FixedPointInt type (scaled by 1e27)\n     */\n    function _getNakedMarginRequired(\n        bytes32 _productHash,\n        FPI.FixedPointInt memory _shortAmount,\n        FPI.FixedPointInt memory _underlyingPrice,\n        FPI.FixedPointInt memory _strikePrice,\n        uint256 _shortExpiryTimestamp,\n        bool _isPut\n    ) internal view returns (FPI.FixedPointInt memory) {\n        // find option upper bound value\n        FPI.FixedPointInt memory optionUpperBoundValue = _findUpperBoundValue(_productHash, _shortExpiryTimestamp);\n        // convert spot shock value of this product to FixedPointInt (already scaled by 1e27)\n        FPI.FixedPointInt memory spotShockValue = FPI.FixedPointInt(int256(spotShock[_productHash]));\n\n        FPI.FixedPointInt memory a;\n        FPI.FixedPointInt memory b;\n        FPI.FixedPointInt memory marginRequired;\n\n        if (_isPut) {\n            a = FPI.min(_strikePrice, spotShockValue.mul(_underlyingPrice));\n            b = FPI.max(_strikePrice.sub(spotShockValue.mul(_underlyingPrice)), ZERO);\n            marginRequired = optionUpperBoundValue.mul(a).add(b).mul(_shortAmount);\n        } else {\n            FPI.FixedPointInt memory one = FPI.fromScaledUint(1e27, SCALING_FACTOR);\n            a = FPI.min(one, _strikePrice.mul(spotShockValue).div(_underlyingPrice));\n            b = FPI.max(one.sub(_strikePrice.mul(spotShockValue).div(_underlyingPrice)), ZERO);\n            marginRequired = optionUpperBoundValue.mul(a).add(b).mul(_shortAmount);\n        }\n\n        return marginRequired;\n    }\n\n    /**\n     * @notice find upper bound value for product by specific expiry timestamp\n     * @dev should return the upper bound value that correspond to option time to expiry, of if not found should return the next greater one, revert if no value found\n     * @param _productHash product hash\n     * @param _expiryTimestamp expiry timestamp\n     * @return option upper bound value\n     */\n    function _findUpperBoundValue(bytes32 _productHash, uint256 _expiryTimestamp)\n        internal\n        view\n        returns (FPI.FixedPointInt memory)\n    {\n        // get time to expiry array of this product hash\n        uint256[] memory timesToExpiry = timesToExpiryForProduct[_productHash];\n\n        // check that this product have upper bound values stored\n        require(timesToExpiry.length != 0, \"MarginCalculator: product have no expiry values\");\n\n        uint256 optionTimeToExpiry = _expiryTimestamp.sub(now);\n\n        // check that the option time to expiry is in the expiry array\n        require(\n            timesToExpiry[timesToExpiry.length.sub(1)] >= optionTimeToExpiry,\n            \"MarginCalculator: product have no upper bound value\"\n        );\n\n        // loop through the array and return the upper bound value in FixedPointInt type (already scaled by 1e27)\n        for (uint8 i = 0; i < timesToExpiry.length; i++) {\n            if (timesToExpiry[i] >= optionTimeToExpiry)\n                return FPI.fromScaledUint(maxPriceAtTimeToExpiry[_productHash][timesToExpiry[i]], SCALING_FACTOR);\n        }\n    }\n\n    /**\n     * @dev returns the strike asset amount of margin required for a put or put spread with the given short oTokens, long oTokens and amounts\n     *\n     * marginRequired = max( (short amount * short strike) - (long strike * min (short amount, long amount)) , 0 )\n     *\n     * @return margin requirement denominated in the strike asset\n     */\n    function _getPutSpreadMarginRequired(\n        FPI.FixedPointInt memory _shortAmount,\n        FPI.FixedPointInt memory _longAmount,\n        FPI.FixedPointInt memory _shortStrike,\n        FPI.FixedPointInt memory _longStrike\n    ) internal view returns (FPI.FixedPointInt memory) {\n        return FPI.max(_shortAmount.mul(_shortStrike).sub(_longStrike.mul(FPI.min(_shortAmount, _longAmount))), ZERO);\n    }\n\n    /**\n     * @dev returns the underlying asset amount required for a call or call spread with the given short oTokens, long oTokens, and amounts\n     *\n     *                           (long strike - short strike) * short amount\n     * marginRequired =  max( ------------------------------------------------- , max (short amount - long amount, 0) )\n     *                                           long strike\n     *\n     * @dev if long strike = 0, return max( short amount - long amount, 0)\n     * @return margin requirement denominated in the underlying asset\n     */\n    function _getCallSpreadMarginRequired(\n        FPI.FixedPointInt memory _shortAmount,\n        FPI.FixedPointInt memory _longAmount,\n        FPI.FixedPointInt memory _shortStrike,\n        FPI.FixedPointInt memory _longStrike\n    ) internal view returns (FPI.FixedPointInt memory) {\n        // max (short amount - long amount , 0)\n        if (_longStrike.isEqual(ZERO)) {\n            return FPI.max(_shortAmount.sub(_longAmount), ZERO);\n        }\n\n        /**\n         *             (long strike - short strike) * short amount\n         * calculate  ----------------------------------------------\n         *                             long strike\n         */\n        FPI.FixedPointInt memory firstPart = _longStrike.sub(_shortStrike).mul(_shortAmount).div(_longStrike);\n\n        /**\n         * calculate max ( short amount - long amount , 0)\n         */\n        FPI.FixedPointInt memory secondPart = FPI.max(_shortAmount.sub(_longAmount), ZERO);\n\n        return FPI.max(firstPart, secondPart);\n    }\n\n    /**\n     * @notice convert an amount in asset A to equivalent amount of asset B, based on a live price\n     * @dev function includes the amount and applies .mul() first to increase the accuracy\n     * @param _amount amount in asset A\n     * @param _assetA asset A\n     * @param _assetB asset B\n     * @return _amount in asset B\n     */\n    function _convertAmountOnLivePrice(\n        FPI.FixedPointInt memory _amount,\n        address _assetA,\n        address _assetB\n    ) internal view returns (FPI.FixedPointInt memory) {\n        if (_assetA == _assetB) {\n            return _amount;\n        }\n        uint256 priceA = oracle.getPrice(_assetA);\n        uint256 priceB = oracle.getPrice(_assetB);\n        // amount A * price A in USD = amount B * price B in USD\n        // amount B = amount A * price A / price B\n        return _amount.mul(FPI.fromScaledUint(priceA, BASE)).div(FPI.fromScaledUint(priceB, BASE));\n    }\n\n    /**\n     * @notice convert an amount in asset A to equivalent amount of asset B, based on an expiry price\n     * @dev function includes the amount and apply .mul() first to increase the accuracy\n     * @param _amount amount in asset A\n     * @param _assetA asset A\n     * @param _assetB asset B\n     * @return _amount in asset B\n     */\n    function _convertAmountOnExpiryPrice(\n        FPI.FixedPointInt memory _amount,\n        address _assetA,\n        address _assetB,\n        uint256 _expiry\n    ) internal view returns (FPI.FixedPointInt memory) {\n        if (_assetA == _assetB) {\n            return _amount;\n        }\n        (uint256 priceA, bool priceAFinalized) = oracle.getExpiryPrice(_assetA, _expiry);\n        (uint256 priceB, bool priceBFinalized) = oracle.getExpiryPrice(_assetB, _expiry);\n        require(priceAFinalized && priceBFinalized, \"MarginCalculator: price at expiry not finalized yet\");\n        // amount A * price A in USD = amount B * price B in USD\n        // amount B = amount A * price A / price B\n        return _amount.mul(FPI.fromScaledUint(priceA, BASE)).div(FPI.fromScaledUint(priceB, BASE));\n    }\n\n    /**\n     * @notice return debt price, how much collateral asset per 1 otoken repaid in collateral decimal\n     * ending price = vault collateral / vault debt\n     * if auction ended, return ending price\n     * else calculate starting price\n     * for put option:\n     * starting price = max(cash value - underlying price * oracle deviation, 0)\n     * for call option:\n     *                      max(cash value - underlying price * oracle deviation, 0)\n     * starting price =  ---------------------------------------------------------------\n     *                                          underlying price\n     *\n     *\n     *                  starting price + (ending price - starting price) * auction elapsed time\n     * then price = --------------------------------------------------------------------------\n     *                                      auction time\n     *\n     *\n     * @param _vaultCollateral vault collateral amount\n     * @param _vaultDebt vault short amount\n     * @param _cashValue option cash value\n     * @param _spotPrice option underlying asset price (in USDC)\n     * @param _auctionStartingTime auction starting timestamp (_spotPrice timestamp from chainlink)\n     * @param _collateralDecimals collateral asset decimals\n     * @param _isPut otoken type, true for put, false for call option\n     * @return price of 1 debt otoken in collateral asset scaled by collateral decimals\n     */\n    function _getDebtPrice(\n        FPI.FixedPointInt memory _vaultCollateral,\n        FPI.FixedPointInt memory _vaultDebt,\n        FPI.FixedPointInt memory _cashValue,\n        FPI.FixedPointInt memory _spotPrice,\n        uint256 _auctionStartingTime,\n        uint256 _collateralDecimals,\n        bool _isPut\n    ) internal view returns (uint256) {\n        // price of 1 repaid otoken in collateral asset, scaled to 1e27\n        FPI.FixedPointInt memory price;\n        // auction ending price\n        FPI.FixedPointInt memory endingPrice = _vaultCollateral.div(_vaultDebt);\n\n        // auction elapsed time\n        uint256 auctionElapsedTime = now.sub(_auctionStartingTime);\n\n        // if auction ended, return ending price\n        if (auctionElapsedTime >= AUCTION_TIME) {\n            price = endingPrice;\n        } else {\n            // starting price\n            FPI.FixedPointInt memory startingPrice;\n\n            {\n                // store oracle deviation in a FixedPointInt (already scaled by 1e27)\n                FPI.FixedPointInt memory fixedOracleDeviation = FPI.fromScaledUint(oracleDeviation, SCALING_FACTOR);\n\n                if (_isPut) {\n                    startingPrice = FPI.max(_cashValue.sub(fixedOracleDeviation.mul(_spotPrice)), ZERO);\n                } else {\n                    startingPrice = FPI.max(_cashValue.sub(fixedOracleDeviation.mul(_spotPrice)), ZERO).div(_spotPrice);\n                }\n            }\n\n            // store auctionElapsedTime in a FixedPointInt scaled by 1e27\n            FPI.FixedPointInt memory auctionElapsedTimeFixedPoint = FPI.fromScaledUint(auctionElapsedTime, 18);\n            // store AUCTION_TIME in a FixedPointInt (already scaled by 1e27)\n            FPI.FixedPointInt memory auctionTime = FPI.fromScaledUint(AUCTION_TIME, 18);\n\n            // calculate price of 1 repaid otoken, scaled by the collateral decimals, expilictly rounded down\n            price = startingPrice.add(\n                (endingPrice.sub(startingPrice)).mul(auctionElapsedTimeFixedPoint).div(auctionTime)\n            );\n\n            // cap liquidation price to ending price\n            if (price.isGreaterThan(endingPrice)) price = endingPrice;\n        }\n\n        return price.toScaledUint(_collateralDecimals, true);\n    }\n\n    /**\n     * @notice get vault details to save us from making multiple external calls\n     * @param _vault vault struct\n     * @param _vaultType vault type, 0 for max loss/spreads and 1 for naked margin vault\n     * @return vault details in VaultDetails struct\n     */\n    function _getVaultDetails(MarginVault.Vault memory _vault, uint256 _vaultType)\n        internal\n        view\n        returns (VaultDetails memory)\n    {\n        VaultDetails memory vaultDetails = VaultDetails(\n            address(0),\n            address(0),\n            address(0),\n            address(0),\n            address(0),\n            address(0),\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            false,\n            false,\n            false,\n            false,\n            false\n        );\n\n        // check if vault has long, short otoken and collateral asset\n        vaultDetails.hasLong = _isNotEmpty(_vault.longOtokens);\n        vaultDetails.hasShort = _isNotEmpty(_vault.shortOtokens);\n        vaultDetails.hasCollateral = _isNotEmpty(_vault.collateralAssets);\n\n        vaultDetails.vaultType = _vaultType;\n\n        // get vault long otoken if available\n        if (vaultDetails.hasLong) {\n            OtokenInterface long = OtokenInterface(_vault.longOtokens[0]);\n            (\n                vaultDetails.longCollateralAsset,\n                vaultDetails.longUnderlyingAsset,\n                vaultDetails.longStrikeAsset,\n                vaultDetails.longStrikePrice,\n                vaultDetails.longExpiryTimestamp,\n                vaultDetails.isLongPut\n            ) = _getOtokenDetails(address(long));\n            vaultDetails.longCollateralDecimals = uint256(ERC20Interface(vaultDetails.longCollateralAsset).decimals());\n        }\n\n        // get vault short otoken if available\n        if (vaultDetails.hasShort) {\n            OtokenInterface short = OtokenInterface(_vault.shortOtokens[0]);\n            (\n                vaultDetails.shortCollateralAsset,\n                vaultDetails.shortUnderlyingAsset,\n                vaultDetails.shortStrikeAsset,\n                vaultDetails.shortStrikePrice,\n                vaultDetails.shortExpiryTimestamp,\n                vaultDetails.isShortPut\n            ) = _getOtokenDetails(address(short));\n            vaultDetails.shortCollateralDecimals = uint256(\n                ERC20Interface(vaultDetails.shortCollateralAsset).decimals()\n            );\n        }\n\n        if (vaultDetails.hasCollateral) {\n            vaultDetails.collateralDecimals = uint256(ERC20Interface(_vault.collateralAssets[0]).decimals());\n        }\n\n        return vaultDetails;\n    }\n\n    /**\n     * @dev calculate the cash value obligation for an expired vault, where a positive number is an obligation\n     *\n     * Formula: net = (short cash value * short amount) - ( long cash value * long Amount )\n     *\n     * @return cash value obligation denominated in the strike asset\n     */\n    function _getExpiredSpreadCashValue(\n        FPI.FixedPointInt memory _shortAmount,\n        FPI.FixedPointInt memory _longAmount,\n        FPI.FixedPointInt memory _shortCashValue,\n        FPI.FixedPointInt memory _longCashValue\n    ) internal pure returns (FPI.FixedPointInt memory) {\n        return _shortCashValue.mul(_shortAmount).sub(_longCashValue.mul(_longAmount));\n    }\n\n    /**\n     * @dev check if asset array contain a token address\n     * @return True if the array is not empty\n     */\n    function _isNotEmpty(address[] memory _assets) internal pure returns (bool) {\n        return _assets.length > 0 && _assets[0] != address(0);\n    }\n\n    /**\n     * @dev ensure that:\n     * a) at most 1 asset type used as collateral\n     * b) at most 1 series of option used as the long option\n     * c) at most 1 series of option used as the short option\n     * d) asset array lengths match for long, short and collateral\n     * e) long option and collateral asset is acceptable for margin with short asset\n     * @param _vault the vault to check\n     * @param _vaultDetails vault details struct\n     */\n    function _checkIsValidVault(MarginVault.Vault memory _vault, VaultDetails memory _vaultDetails) internal pure {\n        // ensure all the arrays in the vault are valid\n        require(_vault.shortOtokens.length <= 1, \"MarginCalculator: Too many short otokens in the vault\");\n        require(_vault.longOtokens.length <= 1, \"MarginCalculator: Too many long otokens in the vault\");\n        require(_vault.collateralAssets.length <= 1, \"MarginCalculator: Too many collateral assets in the vault\");\n\n        require(\n            _vault.shortOtokens.length == _vault.shortAmounts.length,\n            \"MarginCalculator: Short asset and amount mismatch\"\n        );\n        require(\n            _vault.longOtokens.length == _vault.longAmounts.length,\n            \"MarginCalculator: Long asset and amount mismatch\"\n        );\n        require(\n            _vault.collateralAssets.length == _vault.collateralAmounts.length,\n            \"MarginCalculator: Collateral asset and amount mismatch\"\n        );\n\n        // ensure the long asset is valid for the short asset\n        require(\n            _isMarginableLong(_vault, _vaultDetails),\n            \"MarginCalculator: long asset not marginable for short asset\"\n        );\n\n        // ensure that the collateral asset is valid for the short asset\n        require(\n            _isMarginableCollateral(_vault, _vaultDetails),\n            \"MarginCalculator: collateral asset not marginable for short asset\"\n        );\n    }\n\n    /**\n     * @dev if there is a short option and a long option in the vault, ensure that the long option is able to be used as collateral for the short option\n     * @param _vault the vault to check\n     * @param _vaultDetails vault details struct\n     * @return true if long is marginable or false if not\n     */\n    function _isMarginableLong(MarginVault.Vault memory _vault, VaultDetails memory _vaultDetails)\n        internal\n        pure\n        returns (bool)\n    {\n        if (_vaultDetails.vaultType == 1)\n            require(!_vaultDetails.hasLong, \"MarginCalculator: naked margin vault cannot have long otoken\");\n\n        // if vault is missing a long or a short, return True\n        if (!_vaultDetails.hasLong || !_vaultDetails.hasShort) return true;\n\n        return\n            _vault.longOtokens[0] != _vault.shortOtokens[0] &&\n            _vaultDetails.longUnderlyingAsset == _vaultDetails.shortUnderlyingAsset &&\n            _vaultDetails.longStrikeAsset == _vaultDetails.shortStrikeAsset &&\n            _vaultDetails.longCollateralAsset == _vaultDetails.shortCollateralAsset &&\n            _vaultDetails.longExpiryTimestamp == _vaultDetails.shortExpiryTimestamp &&\n            _vaultDetails.isLongPut == _vaultDetails.isShortPut;\n    }\n\n    /**\n     * @dev if there is short option and collateral asset in the vault, ensure that the collateral asset is valid for the short option\n     * @param _vault the vault to check\n     * @param _vaultDetails vault details struct\n     * @return true if marginable or false\n     */\n    function _isMarginableCollateral(MarginVault.Vault memory _vault, VaultDetails memory _vaultDetails)\n        internal\n        pure\n        returns (bool)\n    {\n        bool isMarginable = true;\n\n        if (!_vaultDetails.hasCollateral) return isMarginable;\n\n        if (_vaultDetails.hasShort) {\n            isMarginable = _vaultDetails.shortCollateralAsset == _vault.collateralAssets[0];\n        } else if (_vaultDetails.hasLong) {\n            isMarginable = _vaultDetails.longCollateralAsset == _vault.collateralAssets[0];\n        }\n\n        return isMarginable;\n    }\n\n    /**\n     * @notice get a product hash\n     * @param _underlying option underlying asset\n     * @param _strike option strike asset\n     * @param _collateral option collateral asset\n     * @param _isPut option type\n     * @return product hash\n     */\n    function _getProductHash(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_underlying, _strike, _collateral, _isPut));\n    }\n\n    /**\n     * @notice get option cash value\n     * @dev this assume that the underlying price is denominated in strike asset\n     * cash value = max(underlying price - strike price, 0)\n     * @param _strikePrice option strike price\n     * @param _underlyingPrice option underlying price\n     * @param _isPut option type, true for put and false for call option\n     */\n    function _getCashValue(\n        FPI.FixedPointInt memory _strikePrice,\n        FPI.FixedPointInt memory _underlyingPrice,\n        bool _isPut\n    ) internal view returns (FPI.FixedPointInt memory) {\n        if (_isPut) return _strikePrice.isGreaterThan(_underlyingPrice) ? _strikePrice.sub(_underlyingPrice) : ZERO;\n\n        return _underlyingPrice.isGreaterThan(_strikePrice) ? _underlyingPrice.sub(_strikePrice) : ZERO;\n    }\n\n    /**\n     * @dev get otoken detail, from both otoken versions\n     */\n    function _getOtokenDetails(address _otoken)\n        internal\n        view\n        returns (\n            address,\n            address,\n            address,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        OtokenInterface otoken = OtokenInterface(_otoken);\n        try otoken.getOtokenDetails() returns (\n            address collateral,\n            address underlying,\n            address strike,\n            uint256 strikePrice,\n            uint256 expiry,\n            bool isPut\n        ) {\n            return (collateral, underlying, strike, strikePrice, expiry, isPut);\n        } catch {\n            // v1 otoken\n            return (\n                otoken.collateralAsset(),\n                otoken.underlyingAsset(),\n                otoken.strikeAsset(),\n                otoken.strikePrice(),\n                otoken.expiryTimestamp(),\n                otoken.isPut()\n            );\n        }\n    }\n}\n"
    },
    "contracts/libs/FixedPointInt256.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\nimport \"../packages/oz/SignedSafeMath.sol\";\nimport \"../libs/SignedConverter.sol\";\nimport \"../packages/oz/SafeMath.sol\";\n\n/**\n * @title FixedPointInt256\n * @author Opyn Team\n * @notice FixedPoint library\n */\nlibrary FixedPointInt256 {\n    using SignedSafeMath for int256;\n    using SignedConverter for int256;\n    using SafeMath for uint256;\n    using SignedConverter for uint256;\n\n    int256 private constant SCALING_FACTOR = 1e27;\n    uint256 private constant BASE_DECIMALS = 27;\n\n    struct FixedPointInt {\n        int256 value;\n    }\n\n    /**\n     * @notice constructs an `FixedPointInt` from an unscaled int, e.g., `b=5` gets stored internally as `5**27`.\n     * @param a int to convert into a FixedPoint.\n     * @return the converted FixedPoint.\n     */\n    function fromUnscaledInt(int256 a) internal pure returns (FixedPointInt memory) {\n        return FixedPointInt(a.mul(SCALING_FACTOR));\n    }\n\n    /**\n     * @notice constructs an FixedPointInt from an scaled uint with {_decimals} decimals\n     * Examples:\n     * (1)  USDC    decimals = 6\n     *      Input:  5 * 1e6 USDC  =>    Output: 5 * 1e27 (FixedPoint 5.0 USDC)\n     * (2)  cUSDC   decimals = 8\n     *      Input:  5 * 1e6 cUSDC =>    Output: 5 * 1e25 (FixedPoint 0.05 cUSDC)\n     * @param _a uint256 to convert into a FixedPoint.\n     * @param _decimals  original decimals _a has\n     * @return the converted FixedPoint, with 27 decimals.\n     */\n    function fromScaledUint(uint256 _a, uint256 _decimals) internal pure returns (FixedPointInt memory) {\n        FixedPointInt memory fixedPoint;\n\n        if (_decimals == BASE_DECIMALS) {\n            fixedPoint = FixedPointInt(_a.uintToInt());\n        } else if (_decimals > BASE_DECIMALS) {\n            uint256 exp = _decimals.sub(BASE_DECIMALS);\n            fixedPoint = FixedPointInt((_a.div(10**exp)).uintToInt());\n        } else {\n            uint256 exp = BASE_DECIMALS - _decimals;\n            fixedPoint = FixedPointInt((_a.mul(10**exp)).uintToInt());\n        }\n\n        return fixedPoint;\n    }\n\n    /**\n     * @notice convert a FixedPointInt number to an uint256 with a specific number of decimals\n     * @param _a FixedPointInt to convert\n     * @param _decimals number of decimals that the uint256 should be scaled to\n     * @param _roundDown True to round down the result, False to round up\n     * @return the converted uint256\n     */\n    function toScaledUint(\n        FixedPointInt memory _a,\n        uint256 _decimals,\n        bool _roundDown\n    ) internal pure returns (uint256) {\n        uint256 scaledUint;\n\n        if (_decimals == BASE_DECIMALS) {\n            scaledUint = _a.value.intToUint();\n        } else if (_decimals > BASE_DECIMALS) {\n            uint256 exp = _decimals - BASE_DECIMALS;\n            scaledUint = (_a.value).intToUint().mul(10**exp);\n        } else {\n            uint256 exp = BASE_DECIMALS - _decimals;\n            uint256 tailing;\n            if (!_roundDown) {\n                uint256 remainer = (_a.value).intToUint().mod(10**exp);\n                if (remainer > 0) tailing = 1;\n            }\n            scaledUint = (_a.value).intToUint().div(10**exp).add(tailing);\n        }\n\n        return scaledUint;\n    }\n\n    /**\n     * @notice add two signed integers, a + b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return sum of the two signed integers\n     */\n    function add(FixedPointInt memory a, FixedPointInt memory b) internal pure returns (FixedPointInt memory) {\n        return FixedPointInt(a.value.add(b.value));\n    }\n\n    /**\n     * @notice subtract two signed integers, a-b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return difference of two signed integers\n     */\n    function sub(FixedPointInt memory a, FixedPointInt memory b) internal pure returns (FixedPointInt memory) {\n        return FixedPointInt(a.value.sub(b.value));\n    }\n\n    /**\n     * @notice multiply two signed integers, a by b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return mul of two signed integers\n     */\n    function mul(FixedPointInt memory a, FixedPointInt memory b) internal pure returns (FixedPointInt memory) {\n        return FixedPointInt((a.value.mul(b.value)) / SCALING_FACTOR);\n    }\n\n    /**\n     * @notice divide two signed integers, a by b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return div of two signed integers\n     */\n    function div(FixedPointInt memory a, FixedPointInt memory b) internal pure returns (FixedPointInt memory) {\n        return FixedPointInt((a.value.mul(SCALING_FACTOR)) / b.value);\n    }\n\n    /**\n     * @notice minimum between two signed integers, a and b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return min of two signed integers\n     */\n    function min(FixedPointInt memory a, FixedPointInt memory b) internal pure returns (FixedPointInt memory) {\n        return a.value < b.value ? a : b;\n    }\n\n    /**\n     * @notice maximum between two signed integers, a and b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return max of two signed integers\n     */\n    function max(FixedPointInt memory a, FixedPointInt memory b) internal pure returns (FixedPointInt memory) {\n        return a.value > b.value ? a : b;\n    }\n\n    /**\n     * @notice is a is equal to b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if equal, False if not\n     */\n    function isEqual(FixedPointInt memory a, FixedPointInt memory b) internal pure returns (bool) {\n        return a.value == b.value;\n    }\n\n    /**\n     * @notice is a greater than b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if a > b, False if not\n     */\n    function isGreaterThan(FixedPointInt memory a, FixedPointInt memory b) internal pure returns (bool) {\n        return a.value > b.value;\n    }\n\n    /**\n     * @notice is a greater than or equal to b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if a >= b, False if not\n     */\n    function isGreaterThanOrEqual(FixedPointInt memory a, FixedPointInt memory b) internal pure returns (bool) {\n        return a.value >= b.value;\n    }\n\n    /**\n     * @notice is a is less than b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if a < b, False if not\n     */\n    function isLessThan(FixedPointInt memory a, FixedPointInt memory b) internal pure returns (bool) {\n        return a.value < b.value;\n    }\n\n    /**\n     * @notice is a less than or equal to b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if a <= b, False if not\n     */\n    function isLessThanOrEqual(FixedPointInt memory a, FixedPointInt memory b) internal pure returns (bool) {\n        return a.value <= b.value;\n    }\n}\n"
    },
    "contracts/packages/oz/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts v3.1.0\n\n/* solhint-disable */\npragma solidity ^0.6.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 private constant _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/libs/SignedConverter.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\n/**\n * @title SignedConverter\n * @author Opyn Team\n * @notice A library to convert an unsigned integer to signed integer or signed integer to unsigned integer.\n */\nlibrary SignedConverter {\n    /**\n     * @notice convert an unsigned integer to a signed integer\n     * @param a uint to convert into a signed integer\n     * @return converted signed integer\n     */\n    function uintToInt(uint256 a) internal pure returns (int256) {\n        require(a < 2**255, \"FixedPointInt256: out of int range\");\n\n        return int256(a);\n    }\n\n    /**\n     * @notice convert a signed integer to an unsigned integer\n     * @param a int to convert into an unsigned integer\n     * @return converted unsigned integer\n     */\n    function intToUint(int256 a) internal pure returns (uint256) {\n        if (a < 0) {\n            return uint256(-a);\n        } else {\n            return uint256(a);\n        }\n    }\n}\n"
    },
    "contracts/tests/CalculatorTester.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity =0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {MarginCalculator} from \"../core/MarginCalculator.sol\";\nimport {FixedPointInt256} from \"../libs/FixedPointInt256.sol\";\n\ncontract CalculatorTester is MarginCalculator {\n    constructor(address _addressBook) public MarginCalculator(_addressBook) {}\n\n    function getExpiredCashValue(\n        address _underlying,\n        address _strike,\n        uint256 _expiryTimestamp,\n        uint256 _strikePrice,\n        bool _isPut\n    ) external view returns (uint256) {\n        return\n            FixedPointInt256.toScaledUint(\n                _getExpiredCashValue(_underlying, _strike, _expiryTimestamp, _strikePrice, _isPut),\n                BASE,\n                true\n            );\n    }\n\n    function findUpperBoundValue(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut,\n        uint256 _expiryTimestamp\n    ) external view returns (uint256) {\n        bytes32 productHash = keccak256(abi.encode(_underlying, _strike, _collateral, _isPut));\n\n        return FixedPointInt256.toScaledUint(_findUpperBoundValue(productHash, _expiryTimestamp), 27, false);\n    }\n\n    function price(\n        uint256 _vaultCollateral,\n        uint256 _vaultDebt,\n        uint256 _cv,\n        uint256 _spotPrice,\n        uint256 _auctionStartingTime,\n        uint256 _collateralDecimals,\n        bool _isPut\n    ) external view returns (uint256) {\n        FixedPointInt256.FixedPointInt memory vaultCollateral = FixedPointInt256.fromScaledUint(\n            _vaultCollateral,\n            _collateralDecimals\n        );\n        FixedPointInt256.FixedPointInt memory vaultDebt = FixedPointInt256.fromScaledUint(_vaultDebt, BASE);\n        FixedPointInt256.FixedPointInt memory cv = FixedPointInt256.fromScaledUint(_cv, BASE);\n        FixedPointInt256.FixedPointInt memory spotPrice = FixedPointInt256.fromScaledUint(_spotPrice, BASE);\n\n        return\n            _getDebtPrice(vaultCollateral, vaultDebt, cv, spotPrice, _auctionStartingTime, _collateralDecimals, _isPut);\n    }\n}\n"
    },
    "contracts/tests/FixedPointInt256Tester.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\npragma experimental ABIEncoderV2;\n\nimport \"../libs/FixedPointInt256.sol\";\n\n/**\n * @author Opyn Team\n * @notice FixedPointInt256 contract tester\n */\ncontract FixedPointInt256Tester {\n    using FixedPointInt256 for FixedPointInt256.FixedPointInt;\n\n    function testFromUnscaledInt(int256 a) external pure returns (FixedPointInt256.FixedPointInt memory) {\n        return FixedPointInt256.fromUnscaledInt(a);\n    }\n\n    function testAdd(FixedPointInt256.FixedPointInt memory a, FixedPointInt256.FixedPointInt memory b)\n        external\n        pure\n        returns (FixedPointInt256.FixedPointInt memory)\n    {\n        return a.add(b);\n    }\n\n    function testSub(FixedPointInt256.FixedPointInt memory a, FixedPointInt256.FixedPointInt memory b)\n        external\n        pure\n        returns (FixedPointInt256.FixedPointInt memory)\n    {\n        return a.sub(b);\n    }\n\n    function testMul(FixedPointInt256.FixedPointInt memory a, FixedPointInt256.FixedPointInt memory b)\n        external\n        pure\n        returns (FixedPointInt256.FixedPointInt memory)\n    {\n        return a.mul(b);\n    }\n\n    function testDiv(FixedPointInt256.FixedPointInt memory a, FixedPointInt256.FixedPointInt memory b)\n        external\n        pure\n        returns (FixedPointInt256.FixedPointInt memory)\n    {\n        return a.div(b);\n    }\n\n    function testMin(FixedPointInt256.FixedPointInt memory a, FixedPointInt256.FixedPointInt memory b)\n        external\n        pure\n        returns (FixedPointInt256.FixedPointInt memory)\n    {\n        return FixedPointInt256.min(a, b);\n    }\n\n    function testMax(FixedPointInt256.FixedPointInt memory a, FixedPointInt256.FixedPointInt memory b)\n        external\n        pure\n        returns (FixedPointInt256.FixedPointInt memory)\n    {\n        return FixedPointInt256.max(a, b);\n    }\n\n    function testIsEqual(FixedPointInt256.FixedPointInt memory a, FixedPointInt256.FixedPointInt memory b)\n        external\n        pure\n        returns (bool)\n    {\n        return a.isEqual(b);\n    }\n\n    function testIsGreaterThan(FixedPointInt256.FixedPointInt memory a, FixedPointInt256.FixedPointInt memory b)\n        external\n        pure\n        returns (bool)\n    {\n        return a.isGreaterThan(b);\n    }\n\n    function testIsGreaterThanOrEqual(FixedPointInt256.FixedPointInt memory a, FixedPointInt256.FixedPointInt memory b)\n        external\n        pure\n        returns (bool)\n    {\n        return a.isGreaterThanOrEqual(b);\n    }\n\n    function testIsLessThan(FixedPointInt256.FixedPointInt memory a, FixedPointInt256.FixedPointInt memory b)\n        external\n        pure\n        returns (bool)\n    {\n        return a.isLessThan(b);\n    }\n\n    function testIsLessThanOrEqual(FixedPointInt256.FixedPointInt memory a, FixedPointInt256.FixedPointInt memory b)\n        external\n        pure\n        returns (bool)\n    {\n        return a.isLessThanOrEqual(b);\n    }\n}\n"
    },
    "contracts/tests/SignedConverterTester.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\npragma experimental ABIEncoderV2;\n\nimport \"../libs/SignedConverter.sol\";\n\n/**\n * @author Opyn Team\n * @notice SignedConverter contract tester\n */\ncontract SignedConverterTester {\n    using SignedConverter for int256;\n    using SignedConverter for uint256;\n\n    function testFromInt(int256 a) external pure returns (uint256) {\n        return SignedConverter.intToUint(a);\n    }\n\n    function testFromUint(uint256 a) external pure returns (int256) {\n        return SignedConverter.uintToInt(a);\n    }\n}\n"
    },
    "contracts/tests/MarginVaultTester.sol": {
      "content": "pragma solidity =0.6.10;\n\n// SPDX-License-Identifier: UNLICENSED\npragma experimental ABIEncoderV2;\n\nimport {MarginVault} from \"../libs/MarginVault.sol\";\n\ncontract MarginVaultTester {\n    using MarginVault for MarginVault.Vault;\n\n    mapping(address => mapping(uint256 => MarginVault.Vault)) private vault;\n\n    function getVault(uint256 _vaultIndex) external view returns (MarginVault.Vault memory) {\n        return vault[msg.sender][_vaultIndex];\n    }\n\n    function testAddShort(\n        uint256 _vaultIndex,\n        address _shortOtoken,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        vault[msg.sender][_vaultIndex].addShort(_shortOtoken, _amount, _index);\n    }\n\n    function testRemoveShort(\n        uint256 _vaultIndex,\n        address _shortOtoken,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        vault[msg.sender][_vaultIndex].removeShort(_shortOtoken, _amount, _index);\n    }\n\n    function testAddLong(\n        uint256 _vaultIndex,\n        address _longOtoken,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        vault[msg.sender][_vaultIndex].addLong(_longOtoken, _amount, _index);\n    }\n\n    function testRemoveLong(\n        uint256 _vaultIndex,\n        address _longOtoken,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        vault[msg.sender][_vaultIndex].removeLong(_longOtoken, _amount, _index);\n    }\n\n    function testAddCollateral(\n        uint256 _vaultIndex,\n        address _collateralAsset,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        vault[msg.sender][_vaultIndex].addCollateral(_collateralAsset, _amount, _index);\n    }\n\n    function testRemoveCollateral(\n        uint256 _vaultIndex,\n        address _collateralAsset,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        vault[msg.sender][_vaultIndex].removeCollateral(_collateralAsset, _amount, _index);\n    }\n}\n"
    },
    "contracts/tests/ActionTester.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\npragma experimental ABIEncoderV2;\n\nimport {Actions} from \"../libs/Actions.sol\";\n\ncontract ActionTester {\n    Actions.OpenVaultArgs private openVaultArgs;\n    Actions.DepositArgs private depositArgs;\n    Actions.WithdrawArgs private withdrawArgs;\n    Actions.MintArgs private mintArgs;\n    Actions.BurnArgs private burnArgs;\n    Actions.RedeemArgs private redeemArgs;\n    Actions.SettleVaultArgs private settleVaultArgs;\n    Actions.CallArgs private callArgs;\n    Actions.LiquidateArgs private liquidateArgs;\n\n    function testParseDespositAction(Actions.ActionArgs memory _args) external {\n        depositArgs = Actions._parseDepositArgs(_args);\n    }\n\n    function getDepositArgs() external view returns (Actions.DepositArgs memory) {\n        return depositArgs;\n    }\n\n    function testParseWithdrawAction(Actions.ActionArgs memory _args) external {\n        withdrawArgs = Actions._parseWithdrawArgs(_args);\n    }\n\n    function getWithdrawArgs() external view returns (Actions.WithdrawArgs memory) {\n        return withdrawArgs;\n    }\n\n    function testParseOpenVaultAction(Actions.ActionArgs memory _args) external {\n        openVaultArgs = Actions._parseOpenVaultArgs(_args);\n    }\n\n    function getOpenVaultArgs() external view returns (Actions.OpenVaultArgs memory) {\n        return openVaultArgs;\n    }\n\n    function testParseRedeemAction(Actions.ActionArgs memory _args) external {\n        redeemArgs = Actions._parseRedeemArgs(_args);\n    }\n\n    function getRedeemArgs() external view returns (Actions.RedeemArgs memory) {\n        return redeemArgs;\n    }\n\n    function testParseSettleVaultAction(Actions.ActionArgs memory _args) external {\n        settleVaultArgs = Actions._parseSettleVaultArgs(_args);\n    }\n\n    function testParseLiquidateActions(Actions.ActionArgs memory _args) external {\n        liquidateArgs = Actions._parseLiquidateArgs(_args);\n    }\n\n    function getSettleVaultArgs() external view returns (Actions.SettleVaultArgs memory) {\n        return settleVaultArgs;\n    }\n\n    function testParseMintAction(Actions.ActionArgs memory _args) external {\n        mintArgs = Actions._parseMintArgs(_args);\n    }\n\n    function getMintArgs() external view returns (Actions.MintArgs memory) {\n        return mintArgs;\n    }\n\n    function testParseBurnAction(Actions.ActionArgs memory _args) external {\n        burnArgs = Actions._parseBurnArgs(_args);\n    }\n\n    function getBurnArgs() external view returns (Actions.BurnArgs memory) {\n        return burnArgs;\n    }\n\n    function testParseCallAction(Actions.ActionArgs memory _args) external {\n        callArgs = Actions._parseCallArgs(_args);\n    }\n\n    function getCallArgs() external view returns (Actions.CallArgs memory) {\n        return callArgs;\n    }\n\n    function getLiquidateArgs() external view returns (Actions.LiquidateArgs memory) {\n        return liquidateArgs;\n    }\n}\n"
    },
    "contracts/external/callees/PermitCallee.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity =0.6.10;\n\npragma experimental ABIEncoderV2;\n\nimport {CalleeInterface} from \"../../interfaces/CalleeInterface.sol\";\nimport {IERC20PermitUpgradeable} from \"../../packages/oz/upgradeability/erc20-permit/IERC20PermitUpgradeable.sol\";\n\n/**\n * @title PermitCallee\n * @author Opyn Team\n * @dev Contract for executing permit signature\n */\ncontract PermitCallee is CalleeInterface {\n    function callFunction(address payable _sender, bytes memory _data) external override {\n        (\n            address token,\n            address owner,\n            address spender,\n            uint256 amount,\n            uint256 deadline,\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        ) = abi.decode(_data, (address, address, address, uint256, uint256, uint8, bytes32, bytes32));\n\n        IERC20PermitUpgradeable(token).permit(owner, spender, amount, deadline, v, r, s);\n    }\n}\n"
    },
    "contracts/mocks/Mock0xExchange.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {ZeroXExchangeInterface} from \"../interfaces/ZeroXExchangeInterface.sol\";\nimport {ERC20Interface} from \"../interfaces/ERC20Interface.sol\";\nimport {SafeERC20} from \"../packages/oz/SafeERC20.sol\";\nimport {Mock0xERC20Proxy} from \"./Mock0xERC20Proxy.sol\";\n\n/**\n * @notice Mock 0x Exchange\n */\ncontract Mock0xExchange {\n    using SafeERC20 for ERC20Interface;\n    uint256 public called = 0;\n    uint256 public takerAmount;\n    uint256 public makerAmount;\n    bytes public signature;\n    uint256 public fillAmount;\n    Mock0xERC20Proxy public proxy;\n\n    constructor() public {\n        proxy = new Mock0xERC20Proxy(); //TODO: what is this? do we need it?\n    }\n\n    function fillLimitOrder(\n        ZeroXExchangeInterface.LimitOrder memory _order,\n        ZeroXExchangeInterface.Signature memory _signature,\n        uint128 _takerTokenFillAmount\n    ) public payable returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount) {\n        return (0, 0);\n    }\n\n    function batchFillLimitOrders(\n        ZeroXExchangeInterface.LimitOrder[] memory _orders,\n        ZeroXExchangeInterface.Signature[] memory _signatures,\n        uint128[] memory _takerTokenFillAmounts,\n        bool _revertIfIncomplete\n    ) external payable returns (uint128[] memory takerTokenFilledAmounts, uint128[] memory makerTokenFilledAmounts) {\n        for (uint256 i = 0; i < _orders.length; i++) {\n            (takerTokenFilledAmounts[i], makerTokenFilledAmounts[i]) = fillLimitOrder(\n                _orders[i],\n                _signatures[i],\n                _takerTokenFillAmounts[i]\n            );\n        }\n        return (takerTokenFilledAmounts, makerTokenFilledAmounts);\n    }\n}\n"
    },
    "contracts/interfaces/ZeroXExchangeInterface.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\npragma experimental ABIEncoderV2;\n\n/**\n * @dev ZeroX Exchange contract interface.\n */\ninterface ZeroXExchangeInterface {\n    // solhint-disable max-line-length\n    /// @dev Canonical order structure\n    struct LimitOrder {\n        address makerToken; // The ERC20 token the maker is selling and the maker is selling to the taker.\n        address takerToken; // The ERC20 token the taker is selling and the taker is selling to the maker.\n        uint128 makerAmount; // The amount of makerToken being sold by the maker.\n        uint128 takerAmount; // The amount of takerToken being sold by the taker.\n        uint128 takerTokenFeeAmount; // Amount of takerToken paid by the taker to the feeRecipient.\n        address maker; // The address of the maker, and signer, of this order.\n        address taker; // Allowed taker address. Set to zero to allow any taker.\n        address sender; // Allowed address to call fillLimitOrder() (msg.sender). This is the same as taker, expect when using meta-transactions. Set to zero to allow any caller.\n        address feeRecipient; // Recipient of maker token or taker token fees (if non-zero).\n        bytes32 pool; // The staking pool to attribute the 0x protocol fee from this order. Set to zero to attribute to the default pool, not owned by anyone.\n        uint64 expiry; // The Unix timestamp in seconds when this order expires.\n        uint256 salt; // Arbitrary number to facilitate uniqueness of the order's hash.\n    }\n\n    struct Signature {\n        uint8 signatureType; // Either 2 (EIP712) or 3 (EthSign)\n        uint8 v; // Signature data.\n        bytes32 r; // Signature data.\n        bytes32 s; // Signature data.\n    }\n\n    /// @dev Executes multiple calls of fillLimitOrder.\n    /// @param orders Array of order specifications.\n    /// @param takerTokenFillAmounts Array of desired amounts of takerToken to sell in orders.\n    /// @param signatures Array of proofs that orders have been created by makers.\n    /// @return takerTokenFilledAmounts Array of amount of takerToken(s) filled.\n    /// @return makerTokenFilledAmounts Array of amount of makerToken(s) filled.\n    function batchFillLimitOrders(\n        LimitOrder[] memory orders,\n        Signature[] memory signatures,\n        uint128[] memory takerTokenFillAmounts,\n        bool revertIfIncomplete\n    ) external payable returns (uint128[] memory takerTokenFilledAmounts, uint128[] memory makerTokenFilledAmounts);\n}\n"
    },
    "contracts/mocks/Mock0xERC20Proxy.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {ERC20Interface} from \"../interfaces/ERC20Interface.sol\";\nimport {SafeERC20} from \"../packages/oz/SafeERC20.sol\";\n\n/**\n * @notice Mock 0x ERC20 Proxy\n\n */\ncontract Mock0xERC20Proxy {\n    using SafeERC20 for ERC20Interface;\n\n    function transferToken(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n        ERC20Interface(token).safeTransferFrom(from, to, amount);\n    }\n}\n"
    },
    "contracts/core/MarginPool.sol": {
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity =0.6.10;\n\nimport {ERC20Interface} from \"../interfaces/ERC20Interface.sol\";\nimport {AddressBookInterface} from \"../interfaces/AddressBookInterface.sol\";\nimport {SafeMath} from \"../packages/oz/SafeMath.sol\";\nimport {SafeERC20} from \"../packages/oz/SafeERC20.sol\";\nimport {Ownable} from \"../packages/oz/Ownable.sol\";\n\n/**\n * @author Opyn Team\n * @title MarginPool\n * @notice Contract that holds all protocol funds\n */\ncontract MarginPool is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20Interface;\n\n    /// @notice AddressBook module\n    address public addressBook;\n    /// @dev the address that has the ability to withdraw excess assets in the pool\n    address public farmer;\n    /// @dev mapping between an asset and the amount of the asset in the pool\n    mapping(address => uint256) internal assetBalance;\n\n    /**\n     * @notice contructor\n     * @param _addressBook AddressBook module\n     */\n    constructor(address _addressBook) public {\n        require(_addressBook != address(0), \"Invalid address book\");\n\n        addressBook = _addressBook;\n    }\n\n    /// @notice emits an event when marginpool receive funds from controller\n    event TransferToPool(address indexed asset, address indexed user, uint256 amount);\n    /// @notice emits an event when marginpool transfer funds to controller\n    event TransferToUser(address indexed asset, address indexed user, uint256 amount);\n    /// @notice emit event after updating the farmer address\n    event FarmerUpdated(address indexed oldAddress, address indexed newAddress);\n    /// @notice emit event when an asset gets harvested from the pool\n    event AssetFarmed(address indexed asset, address indexed receiver, uint256 amount);\n\n    /**\n     * @notice check if the sender is the Controller module\n     */\n    modifier onlyController() {\n        require(\n            msg.sender == AddressBookInterface(addressBook).getController(),\n            \"MarginPool: Sender is not Controller\"\n        );\n\n        _;\n    }\n\n    /**\n     * @notice check if the sender is the farmer address\n     */\n    modifier onlyFarmer() {\n        require(msg.sender == farmer, \"MarginPool: Sender is not farmer\");\n\n        _;\n    }\n\n    /**\n     * @notice transfers an asset from a user to the pool\n     * @param _asset address of the asset to transfer\n     * @param _user address of the user to transfer assets from\n     * @param _amount amount of the token to transfer from _user\n     */\n    function transferToPool(\n        address _asset,\n        address _user,\n        uint256 _amount\n    ) public onlyController {\n        require(_amount > 0, \"MarginPool: transferToPool amount is equal to 0\");\n        assetBalance[_asset] = assetBalance[_asset].add(_amount);\n\n        // transfer _asset _amount from _user to pool\n        ERC20Interface(_asset).safeTransferFrom(_user, address(this), _amount);\n        emit TransferToPool(_asset, _user, _amount);\n    }\n\n    /**\n     * @notice transfers an asset from the pool to a user\n     * @param _asset address of the asset to transfer\n     * @param _user address of the user to transfer assets to\n     * @param _amount amount of the token to transfer to _user\n     */\n    function transferToUser(\n        address _asset,\n        address _user,\n        uint256 _amount\n    ) public onlyController {\n        require(_user != address(this), \"MarginPool: cannot transfer assets to oneself\");\n        assetBalance[_asset] = assetBalance[_asset].sub(_amount);\n\n        // transfer _asset _amount from pool to _user\n        ERC20Interface(_asset).safeTransfer(_user, _amount);\n        emit TransferToUser(_asset, _user, _amount);\n    }\n\n    /**\n     * @notice get the stored balance of an asset\n     * @param _asset asset address\n     * @return asset balance\n     */\n    function getStoredBalance(address _asset) external view returns (uint256) {\n        return assetBalance[_asset];\n    }\n\n    /**\n     * @notice transfers multiple assets from users to the pool\n     * @param _asset addresses of the assets to transfer\n     * @param _user addresses of the users to transfer assets to\n     * @param _amount amount of each token to transfer to pool\n     */\n    function batchTransferToPool(\n        address[] memory _asset,\n        address[] memory _user,\n        uint256[] memory _amount\n    ) external onlyController {\n        require(\n            _asset.length == _user.length && _user.length == _amount.length,\n            \"MarginPool: batchTransferToPool array lengths are not equal\"\n        );\n\n        for (uint256 i = 0; i < _asset.length; i++) {\n            // transfer _asset _amount from _user to pool\n            transferToPool(_asset[i], _user[i], _amount[i]);\n        }\n    }\n\n    /**\n     * @notice transfers multiple assets from the pool to users\n     * @param _asset addresses of the assets to transfer\n     * @param _user addresses of the users to transfer assets to\n     * @param _amount amount of each token to transfer to _user\n     */\n    function batchTransferToUser(\n        address[] memory _asset,\n        address[] memory _user,\n        uint256[] memory _amount\n    ) external onlyController {\n        require(\n            _asset.length == _user.length && _user.length == _amount.length,\n            \"MarginPool: batchTransferToUser array lengths are not equal\"\n        );\n\n        for (uint256 i = 0; i < _asset.length; i++) {\n            // transfer _asset _amount from pool to _user\n            transferToUser(_asset[i], _user[i], _amount[i]);\n        }\n    }\n\n    /**\n     * @notice function to collect the excess balance of a particular asset\n     * @dev can only be called by the farmer address. Do not farm otokens.\n     * @param _asset asset address\n     * @param _receiver receiver address\n     * @param _amount amount to remove from pool\n     */\n    function farm(\n        address _asset,\n        address _receiver,\n        uint256 _amount\n    ) external onlyFarmer {\n        require(_receiver != address(0), \"MarginPool: invalid receiver address\");\n\n        uint256 externalBalance = ERC20Interface(_asset).balanceOf(address(this));\n        uint256 storedBalance = assetBalance[_asset];\n\n        require(_amount <= externalBalance.sub(storedBalance), \"MarginPool: amount to farm exceeds limit\");\n\n        ERC20Interface(_asset).safeTransfer(_receiver, _amount);\n\n        emit AssetFarmed(_asset, _receiver, _amount);\n    }\n\n    /**\n     * @notice function to set farmer address\n     * @dev can only be called by MarginPool owner\n     * @param _farmer farmer address\n     */\n    function setFarmer(address _farmer) external onlyOwner {\n        emit FarmerUpdated(farmer, _farmer);\n\n        farmer = _farmer;\n    }\n}\n"
    },
    "contracts/mocks/MockDumbERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable */\npragma solidity ^0.6.0;\n\nimport {SafeMath} from \"../packages/oz/SafeMath.sol\";\n\n/**\n * ERC20 Token that return false when operation failed\n */\ncontract MockDumbERC20 {\n    using SafeMath for uint256;\n\n    bool internal _locked;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual returns (bool) {\n        if (_locked) return false;\n        if (_balances[msg.sender] < amount) {\n            return false;\n        }\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        _allowances[msg.sender][spender] = _allowances[msg.sender][spender].add(amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual returns (bool) {\n        if (_locked) return false;\n        if (_balances[sender] < amount) {\n            return false;\n        }\n        if (_allowances[sender][msg.sender] < amount) {\n            return false;\n        }\n        _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount);\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        return true;\n    }\n\n    function mint(address recipient, uint256 amount) public {\n        _balances[recipient] = _balances[recipient].add(amount);\n    }\n\n    function burn(address recipient, uint256 amount) public {\n        _balances[recipient] = _balances[recipient].sub(amount);\n    }\n\n    function setLocked(bool locked_) public {\n        _locked = locked_;\n    }\n}\n"
    },
    "contracts/mocks/MockCToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\nimport {ERC20Upgradeable} from \"../packages/oz/upgradeability/ERC20Upgradeable.sol\";\n\ncontract MockCToken is ERC20Upgradeable {\n    uint256 public exchangeRateStored;\n\n    constructor(string memory _name, string memory _symbol) public {\n        __ERC20_init_unchained(_name, _symbol);\n        _setupDecimals(8);\n    }\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    function setExchangeRate(uint256 _exchangeRateStored) external {\n        exchangeRateStored = _exchangeRateStored;\n    }\n}\n"
    },
    "contracts/core/Otoken.sol": {
      "content": "/* SPDX-License-Identifier: UNLICENSED */\npragma solidity =0.6.10;\n\nimport {ERC20Upgradeable} from \"../packages/oz/upgradeability/ERC20Upgradeable.sol\";\nimport {ERC20PermitUpgradeable} from \"../packages/oz/upgradeability/erc20-permit/ERC20PermitUpgradeable.sol\";\nimport {Strings} from \"../packages/oz/Strings.sol\";\nimport {BokkyPooBahsDateTimeLibrary} from \"../packages/BokkyPooBahsDateTimeLibrary.sol\";\nimport {AddressBookInterface} from \"../interfaces/AddressBookInterface.sol\";\n\n/**\n * @title Otoken\n * @author Opyn Team\n * @notice Otoken is the ERC20 token for an option\n * @dev The Otoken inherits ERC20Upgradeable because we need to use the init instead of constructor\n */\ncontract Otoken is ERC20PermitUpgradeable {\n    /// @notice address of the Controller module\n    address public controller;\n\n    /// @notice asset that the option references\n    address public underlyingAsset;\n\n    /// @notice asset that the strike price is denominated in\n    address public strikeAsset;\n\n    /// @notice asset that is held as collateral against short/written options\n    address public collateralAsset;\n\n    /// @notice strike price with decimals = 8\n    uint256 public strikePrice;\n\n    /// @notice expiration timestamp of the option, represented as a unix timestamp\n    uint256 public expiryTimestamp;\n\n    /// @notice True if a put option, False if a call option\n    bool public isPut;\n\n    uint256 private constant STRIKE_PRICE_SCALE = 1e8;\n    uint256 private constant STRIKE_PRICE_DIGITS = 8;\n\n    /**\n     * @notice initialize the oToken\n     * @param _addressBook addressbook module\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 8\n     * @param _expiryTimestamp expiration timestamp of the option, represented as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     */\n    function init(\n        address _addressBook,\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTimestamp,\n        bool _isPut\n    ) external initializer {\n        controller = AddressBookInterface(_addressBook).getController();\n        underlyingAsset = _underlyingAsset;\n        strikeAsset = _strikeAsset;\n        collateralAsset = _collateralAsset;\n        strikePrice = _strikePrice;\n        expiryTimestamp = _expiryTimestamp;\n        isPut = _isPut;\n        (string memory tokenName, string memory tokenSymbol) = _getNameAndSymbol();\n        __ERC20_init_unchained(tokenName, tokenSymbol);\n        __ERC20Permit_init(tokenName);\n        _setupDecimals(8);\n    }\n\n    function getOtokenDetails()\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        return (collateralAsset, underlyingAsset, strikeAsset, strikePrice, expiryTimestamp, isPut);\n    }\n\n    /**\n     * @notice mint oToken for an account\n     * @dev Controller only method where access control is taken care of by _beforeTokenTransfer hook\n     * @param account account to mint token to\n     * @param amount amount to mint\n     */\n    function mintOtoken(address account, uint256 amount) external {\n        require(msg.sender == controller, \"Otoken: Only Controller can mint Otokens\");\n        _mint(account, amount);\n    }\n\n    /**\n     * @notice burn oToken from an account.\n     * @dev Controller only method where access control is taken care of by _beforeTokenTransfer hook\n     * @param account account to burn token from\n     * @param amount amount to burn\n     */\n    function burnOtoken(address account, uint256 amount) external {\n        require(msg.sender == controller, \"Otoken: Only Controller can burn Otokens\");\n        _burn(account, amount);\n    }\n\n    /**\n     * @notice generates the name and symbol for an option\n     * @dev this function uses a named return variable to avoid the stack-too-deep error\n     * @return tokenName (ex: ETHUSDC 05-September-2020 200 Put USDC Collateral)\n     * @return tokenSymbol (ex: oETHUSDC-05SEP20-200P)\n     */\n    function _getNameAndSymbol() internal view returns (string memory tokenName, string memory tokenSymbol) {\n        string memory underlying = ERC20Upgradeable(underlyingAsset).symbol();\n        string memory strike = ERC20Upgradeable(strikeAsset).symbol();\n        string memory collateral = ERC20Upgradeable(collateralAsset).symbol();\n        string memory displayStrikePrice = _getDisplayedStrikePrice(strikePrice);\n\n        // convert expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary.timestampToDate(expiryTimestamp);\n\n        // get option type string\n        (string memory typeSymbol, string memory typeFull) = _getOptionType(isPut);\n\n        //get option month string\n        (string memory monthSymbol, string memory monthFull) = _getMonth(month);\n\n        // concatenated name string: ETHUSDC 05-September-2020 200 Put USDC Collateral\n        tokenName = string(\n            abi.encodePacked(\n                underlying,\n                strike,\n                \" \",\n                _uintTo2Chars(day),\n                \"-\",\n                monthFull,\n                \"-\",\n                Strings.toString(year),\n                \" \",\n                displayStrikePrice,\n                typeFull,\n                \" \",\n                collateral,\n                \" Collateral\"\n            )\n        );\n\n        // concatenated symbol string: oETHUSDC/USDC-05SEP20-200P\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"o\",\n                underlying,\n                strike,\n                \"/\",\n                collateral,\n                \"-\",\n                _uintTo2Chars(day),\n                monthSymbol,\n                _uintTo2Chars(year),\n                \"-\",\n                displayStrikePrice,\n                typeSymbol\n            )\n        );\n    }\n\n    /**\n     * @dev convert strike price scaled by 1e8 to human readable number string\n     * @param _strikePrice strike price scaled by 1e8\n     * @return strike price string\n     */\n    function _getDisplayedStrikePrice(uint256 _strikePrice) internal pure returns (string memory) {\n        uint256 remainder = _strikePrice.mod(STRIKE_PRICE_SCALE);\n        uint256 quotient = _strikePrice.div(STRIKE_PRICE_SCALE);\n        string memory quotientStr = Strings.toString(quotient);\n\n        if (remainder == 0) return quotientStr;\n\n        uint256 trailingZeroes;\n        while (remainder.mod(10) == 0) {\n            remainder = remainder / 10;\n            trailingZeroes += 1;\n        }\n\n        // pad the number with \"1 + starting zeroes\"\n        remainder += 10**(STRIKE_PRICE_DIGITS - trailingZeroes);\n\n        string memory tmpStr = Strings.toString(remainder);\n        tmpStr = _slice(tmpStr, 1, 1 + STRIKE_PRICE_DIGITS - trailingZeroes);\n\n        string memory completeStr = string(abi.encodePacked(quotientStr, \".\", tmpStr));\n        return completeStr;\n    }\n\n    /**\n     * @dev return a representation of a number using 2 characters, adds a leading 0 if one digit, uses two trailing digits if a 3 digit number\n     * @return 2 characters that corresponds to a number\n     */\n    function _uintTo2Chars(uint256 number) internal pure returns (string memory) {\n        if (number > 99) number = number % 100;\n        string memory str = Strings.toString(number);\n        if (number < 10) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n        return str;\n    }\n\n    /**\n     * @dev return string representation of option type\n     * @return shortString a 1 character representation of option type (P or C)\n     * @return longString a full length string of option type (Put or Call)\n     */\n    function _getOptionType(bool _isPut) internal pure returns (string memory shortString, string memory longString) {\n        if (_isPut) {\n            return (\"P\", \"Put\");\n        } else {\n            return (\"C\", \"Call\");\n        }\n    }\n\n    /**\n     * @dev cut string s into s[start:end]\n     * @param _s the string to cut\n     * @param _start the starting index\n     * @param _end the ending index (excluded in the substring)\n     */\n    function _slice(\n        string memory _s,\n        uint256 _start,\n        uint256 _end\n    ) internal pure returns (string memory) {\n        bytes memory a = new bytes(_end - _start);\n        for (uint256 i = 0; i < _end - _start; i++) {\n            a[i] = bytes(_s)[_start + i];\n        }\n        return string(a);\n    }\n\n    /**\n     * @dev return string representation of a month\n     * @return shortString a 3 character representation of a month (ex: SEP, DEC, etc)\n     * @return longString a full length string of a month (ex: September, December, etc)\n     */\n    function _getMonth(uint256 _month) internal pure returns (string memory shortString, string memory longString) {\n        if (_month == 1) {\n            return (\"JAN\", \"January\");\n        } else if (_month == 2) {\n            return (\"FEB\", \"February\");\n        } else if (_month == 3) {\n            return (\"MAR\", \"March\");\n        } else if (_month == 4) {\n            return (\"APR\", \"April\");\n        } else if (_month == 5) {\n            return (\"MAY\", \"May\");\n        } else if (_month == 6) {\n            return (\"JUN\", \"June\");\n        } else if (_month == 7) {\n            return (\"JUL\", \"July\");\n        } else if (_month == 8) {\n            return (\"AUG\", \"August\");\n        } else if (_month == 9) {\n            return (\"SEP\", \"September\");\n        } else if (_month == 10) {\n            return (\"OCT\", \"October\");\n        } else if (_month == 11) {\n            return (\"NOV\", \"November\");\n        } else {\n            return (\"DEC\", \"December\");\n        }\n    }\n}\n"
    },
    "contracts/packages/oz/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts v3.1.0\n\n/* solhint-disable */\npragma solidity =0.6.10;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + (temp % 10)));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/packages/BokkyPooBahsDateTimeLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable\npragma solidity ^0.6.0;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\n// version v1.01\nlibrary BokkyPooBahsDateTimeLibrary {\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint256 _days)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        int256 __days = int256(_days);\n\n        int256 L = __days + 68569 + OFFSET19700101;\n        int256 N = (4 * L) / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int256 _year = (4000 * (L + 1)) / 1461001;\n        L = L - (1461 * _year) / 4 + 31;\n        int256 _month = (80 * L) / 2447;\n        int256 _day = L - (2447 * _month) / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint256(_year);\n        month = uint256(_month);\n        day = uint256(_day);\n    }\n\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 99999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}